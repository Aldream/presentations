<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JS1K, Retour d'expérience | Benjamin (Bill) Planche</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js-2.6.1/css/reveal.min.css">
		<link rel="stylesheet" href="reveal.js-2.6.1/css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js-2.6.1/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>JS1K</h1>
					<h2>Retour d'expérience</h2>
					<p>
						<small>Par <a href="http://aldream.net">Benjamin (Bill) Planche</a><br/>
						Slides dispo sur <a href="https://github.com/Aldream/presentations">github.com/Aldream/presentations</a></small>
					</p>

					<aside class="notes">
						Présentation = Retour d'expérience sur le concours de prog JS1K.
						Si vous préférez suivre sur votre PC ou si vous voulez récup' les slides, direction Github.
						Maintenant, avant toute chose, j'aimerais vous présenter un bout de code et avoir votre avis dessus.
					</aside>
				</section>

				<section>
					<section>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; white-space: -moz-pre-wrap;word-wrap: break-word;">_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9>l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6>]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h>p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)</code></pre>
						<p>?</p>

						<aside class="notes">
							Qu'en pensez-vous ? Une idée du langage, de ce qu'il peut bien faire ?
							Même le colorateur syntaxique ne sait pas trop comment l'interprêter ...
							Bon, après, il y a quelques indices hein... Déjà vous êtes à une conf' LyonJS, vous vous doutez que c'est pas du Cobol...
							Et puis il y a des indices... "eval", "join", "pop", "with" "setInterval", "hsla", ...
							Mais il y a aussi des aspects vraiment bizarres ... "Math.;", des syntaxes qui semblent ne pas aller du tout...
						</aside>
					</section>
					<section>
						<h3>... et avec un peu plus de contexte ?</h3>
					</section>
					<section>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; font-size: 0.9em; white-space: -moz-pre-wrap;word-wrap: break-word;">&lt;!doctype html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;JS1k, 1k demo submission [ID]&lt;/title&gt;
		&lt;meta charset="utf-8" /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;canvas id="c"&gt;&lt;/canvas&gt;
		&lt;script&gt;
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		&lt;/script&gt;
		&lt;script&gt;
// start of submission //
_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9&gt;l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6&gt;]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h&gt;p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)
// end of submission //
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
						<p> ... ?</p>

						<aside class="notes">
							Si on remet ce script dans son contexte, cad au sein de la page web auquel il appartient, est-ce qu'on est plus aidé ... ? Un peu, mais pas des masses.
							C'est bien du JS ... Il semble autonome, aucun autre script chargé. Juste 3 déclarations permettant d'accéder au body, canvas et context... La page est vraiment dépouillée.
							On remarque aussi que le code est finalement contenu en grande partie dans une string, d'où le eval final ...
							Maintenant, que se passe-t-il si on copie-colle le tout et lance dans votre navigateur favori ... ?
							
							Présentation de la démo :
							Tout de suite, ca ressemble un peu plus à quelque chose. Donc de quoi s'agit-il ?
							Un p'tit programme JS capable de générer, de manière pseudo-aléatoire, un paysage.
							Ce paysage possède diverses caractéristiques ...
							- Une étendue d'eau, avec un jeu dynamique de lumières et reflets.
							- Une fine plage de sable blanc au bord de l'eau
							- Un massif verdoyant
							- Des sommets rocheux et enneigés
							L'éclairage est simulé via la notion d'illumination, avec des ombres plus ou moins éclairées / ombragées en fonction de leur orientation.
							Si vous rechargez la page, un nouveau paysage apparait. Il se dessine dynamiquement, par ajout de p'tits points de couleur.
							D'où le nom de cette démo, "Pointillism".
							Cette génération continue permet également d'ajouter une certain dynamique, utilisée pour simuler le passage des saisons :
							- Jaunissement de la foret
							- Descente de la neige.
							- Passage de nuage (ombres projetées)
							Enfin, il est possible d'interagir avec, de s'y déplacer. Rotation zoom ...
							
							Bref, il s'agit donc de ma démo principale proposée pour le concours JS1K 2013. Et quelle est sa particularité ?
						</aside>
					</section>
					<section>
						<h2>1024 octets</h2>
						<p class="fragment">c'est peu.</p>

						<aside class="notes">
							Elle tient sur 1024 octets.
							Comme ça, c'est peut-être un peu dur à se représenter, mais 1024o ... c'est peu !
						</aside>
					</section>
					<section>
						<h3>Exemple</h3>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; white-space: -moz-pre-wrap;word-wrap: break-word;">
Ce programme Javascript permet de générer procéduralement des paysages. Ces paysages doivent contenir un relief assez montagneux, ainsi qu'une étendue d'eau. L'utilisateur doit pouvoir se déplacer dans la scène : il peut naviguer autour du paysage en maintenant le clic gauche de la souris et en déplaçant celle-ci, ou s'approcher / s'éloigner à l'aide de la molette. Le paysage se génère continuellement, par ajouts de petites tâches de couleur (plus grosses lors des déplacements pour obtenir plus rapidement un aperçu). A chaque chargement de la page, le contenu doit être différent (génération pseudo-aléatoire). La scène doit être suffisamment détaillée pour donner une impression de réalisme et d'étendue. Dans la même optique, la notion d'illumination doit être simulée, en obscurcissant les zones adéquates. Afin de correspondre au thème printanier du concours, une notion de défilement du temps doit être exprimée. On donnera donc l'impression du passage des saisons grâce à l...
						</code></pre>

						<aside class="notes">
							Pour donner une idée, je me suis amusé à mettre à l'écrit la description verbale, en français, de ma démo.
							En essayant d'éviter tout barratin, en restant concis et pro...
							Sur 1024 octets (caractères ici par simplification), je n'ai même pas pu faire tenir la moitié.
						</aside>
					</section>
					
					
					<section>
						<h2>Essence du concours JS1K :</h2>
						<p>Faire beaucoup avec peu</p>
						<p>Code minimaliste / immonde &rarr; Programme cool</p>
						

						<aside class="notes">
							Ce soucis de concision, c'est l'esprit même du concours JS1K.
							JS - Javascript, 1K - 1ko, ie 1024 octets, vous l'aurez compris ...
							Son but est de pousser les programmeurs à faire beaucoup avec peu, à utiliser toute leur connaissance du langage, toute leur imagination et leur astuce pour réaliser quelque chose d'intéressant avec une forte contrainte d'espace.
							Et donc par la même occasion, de démontrer le pouvoir d'expression du JS ...
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Avertissements !</h2>

						<aside class="notes">
							Dernière chose avant d'entrer enfin dans le vif du sujet ...
						</aside>
					</section>
					
					<section>
						<p>Le JS présenté ici n'est pas conforme W3C.</p>

						<aside class="notes">
							Premièrement, le code présenté est loin de se conformer à la plupart des règles de bonne pratique. Il n'est pas forcément cross-browser. Il n'est pas aisément maintenable, et carrément illisible.
						</aside>
					</section>
					
					<section>
						<p>A ne pas reproduire en entreprise.</p>

						<aside class="notes">
							Pour toutes ces raisons, je vous invite fortement à ne pas le reproduire en entreprise. Après je veux pas généraliser hein ... Mais j'aimerais pas être la personne (le stagiaire donc) chargée de maintenir ce genre de script ...
						</aside>
					</section>
					
					<section>
						<p>Peut entrainer TOC, insomnie et troubles de l'attention.</p>
						<p>Tenir hors de la portée et de la vue des programmeurs juniors.</p>
						<p>Ne pas dépasser la posologie conseillée.</p>
						<p>En cas d'effets indésirables, contactez votre lead-developer.</p>

						<aside class="notes">
							Enfin ... Par rapport au concours même ...
							Si vous songez à y participer un jour, soyez prévenus ... Vous allez y passer du temps et des larmes.
							Vous ne verrez probablement plus le JS de la même manière, et risquez d'attraper de très sales habitudes ...
							Cela étant dit ...
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>JS1K</h1>

						<aside class="notes">
							Qu'est-ce que JS1K exactement ?
						</aside>
					</section>
					
					<section>
						<a href="http://js1k.com" title="JS1K"><img src="img/js1k.png" alt="JS1K logo" /></a>

						<aside class="notes">
							- Montrer le site Web -
							
							Concours JS débuté en 2010 à l'initative de Peter van der Zee (@kuvos), un web-developeur néerlandais.
							Il y a déjà eu 5 sessions, à raison de 2 en 2012.
							Site très simple :
							- Page d'accueil avec le jury, les prix, les démos gagnantes.
							- Règles
							- Liste de toutes les démos
							
							Les jurys bénévoles sont des grands noms de la scène JS. Paul Irish, Juriy Zaytsev (Fabric.js), ...
							Le prix est constitué à partir de généreuses donation, et est réparti entre les X premiers (tout pour le 1er en 2013).
							Les 10 démos nominées par le jury ont la chance de rester à la postérité, en apparaissant direct sur la page d'accueil.
							Bon, ce n'est donc pas THE concours qui vous fera connaitre dans le monde de la programmation, mais cela reste l'occasion de cotoyer des passionnés - plus ou moins influents -, et de malgré tout se faire un p'tit nom, au moins auprès de ceux-ci.
						</aside>
					</section>
					
					<section>
						<h2>Règlement</h2>
						
						<ul>
							<li class="fragment">Javascript, intégré au template html fourni</li>
							<li class="fragment">1024 octets max</li>
							<li class="fragment">Pas de ressources externes (lib, img, api, ...)</li>
							<li class="fragment">Cross-browser (récents)</li>
							<li class="fragment">Doit simplement fonctionner (au diable les best practices)</li>
						</ul>

						<aside class="notes">
							Les principales règles sont on-ne-peut-plus-simples :
							- JS pur, qui sera intégré dans le template fourni.
							- 1024o max, ofc
							- Le script doit fonctionné hors-connexion. Pas de ressources externes (même API)
							- Cross-browser autant que possible (Chrome, Firefox, Opera)
							- Rien à faire de la syntaxe et présentation. Ca doit marcher, point.
						</aside>
					</section>
					
					<section>
						<h2>Template (shim)</h2>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%; white-space: -moz-pre-wrap;word-wrap: break-word;">&lt;!doctype html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;JS1k, 1k demo submission [ID]&lt;/title&gt;
		&lt;meta charset="utf-8" /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;canvas id="c"&gt;&lt;/canvas&gt;
		&lt;script&gt;
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit
		&lt;/script&gt;
		&lt;script&gt;
// start of submission //
SCRIPT
// end of submission //
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>

						<aside class="notes">
							Le Shim, le template que vous avez déjà pu observer auparavant. Une page dénudée avec un simple canvas. Trois déclarations pouvant aider. Rien d'autre.
							Libre à vous de modifier le DOM, mais uniquement via le script JS (pas le droit de refermer la balise script pour ajouter du HTML.
						</aside>
						
					</section>
				</section>

				<section>
					<section>
						<h1>Mon Histoire</h1>

						<aside class="notes">
							Et moi dans tout ça, je suis quoi ?
						</aside>
					</section>
					
					<section>
						<h2>Qui suis-je ?</h2>
					</section>
					
					<section>
						<h3>Benjamin (Bill) Planche, aka Aldream</h3>
						<ul>
							<li>Etudiant INSA-Lyon</li>
							<li>Spécialités : Web, AI & CG</li>
						</ul>

						<aside class="notes">
							Benjamin Planche, plus communément nommé Bill. Pseudonyme Aldream sur le Web.
							INSA-Lyon
							Passionné par le Web depuis assez jeune. Aime aussi appliqué les maths ou l'art à l'informatique. J'ai eu l'occasion de bosser dans la robotique, le traitement d'image, la domotique, ...
						</aside>
					</section>
					
					<section>
						<h3>Contexte</h3>
						<ul>
							<li>Fan de JS1K sans jamais participer auparavant</li>
							<li>En année de césure quand JS1K 2013 a été annoncé</li>
							<li>Avais déjà tenté de traduire ce projet Matlab en JS</li>
						</ul>

						<aside class="notes">
							J'avais découvert JS1K il y a deux ans, durant la session 2012. J'ai regardé les choses de loin, en admirant les créations postées, sans vraiment m'imaginer, sur le coup, tenter ...
							Et puis j'ai effectué une année de césure. Malgré le boulot et la visite d'un pays étranger, je me retrouvais soudain avec plus de temps libre que ce dont j'avais l'habitude depuis le début de mes études supérieures.
							J'ai donc (re)pris l'habitude de coder pour le plaisir, des p'tits projets perso, mon site web, ...
							C'est aussi à cette époque qu j'ai commencé à me repencher sur un ancien projet. Un programme JS traduit d'un projet scolaire Matlab, qui générait un simple paysage ...
						</aside>
					</section>
					
					<section>
						<h2>Elaboration</h2>
					</section>
					
					<section>
						<h3>Première Tentative</h3>
						<h4>ou comment je perdis 2 semaines et toute confiance</h4>
						<p class="fragment">Tenter de compresser un script JS codé auparavant</p>

						<aside class="notes">
							Quand la session 2013 de JS1K a été annoncé en le 1er Février, j'ai donc directement songé à ce projet.
							Je me suis dit "Il suffirait de le minimiser, de supprimer le surplus, d'inliner certaines fonctions, de ne garder que le nécessaire des librairies utilisées, ..."
							Grave erreur.
						</aside>
					</section>
					
					<section>
						<h3>Pourquoi ce fut une erreur ?</h3>
						<ul>
							<li class="fragment">Buggé de base, mal structuré (erreurs de jeunesse...)</li>
							<li class="fragment">ET SURTOUT, pas adapté aux nouvelles contraintes</li>
						</ul>

						<aside class="notes">
							Pourquoi ?
							Parce que déjà, mon script était foireux de base. Mal codé, un peu buggé, ... Sur le coup, je me suis au moins rendu compte de mes progrès en programmation ...
							Et puis surtout, parce que ce script n'avait pas été développé de base dans l'optique d'être compact.
							Et mine de rien, c'est une propriété qui devient intrasèque.
							Une telle démo doit être codée avec deux optiques : le but même de la démo, et le respect de la taille.
							Les deux sont à prendre autant en compte et influenceront tout autant la rédaction du code.
							Je l'ai compris après 10 jours à galérer ...
						</aside>
					</section>
					
					<section>
						<h3>Deuxième Tentative</h3>
						<h4>Partir de la Base</h4>
						<ul>
							<li class="fragment">Algo de visualisation 3D</li>
							<li class="fragment">Algo de génération procédurale</li>
						</ul>

						<aside class="notes">
							J'ai donc tout mis de côté, et je suis reparti du début.
							J'ai commencé par revoir les algos destinés à ce que je voulais faire, à les étudier en profondeur, à les comparer.
							Si vous êtes intéressé par ce genre d'algorithmie et de maths (géométrie 3D, génération procédurale, transormations, fonctions stochastiques, interpolation, ...), on pourra en discuter après ou vous pourrez aller voir un article que j'ai fait. Ce n'est peut-être pas le sujet de cette conférence.
							Bref, je suis donc reparti de 0. J'ai tout recodé par incrément, jusqu'à satisfaction.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Compression</h1>

						<aside class="notes">
							En passant dnoc outre le contenu même du code, un aspect très important dans la création de ces démos, c'est la phase de minimisation / compression.
							Des techniques et des outils existent pour aider dans cette quête, qui ne se limitent pas au concours JS1K mais peuvent servir plus couramment ...
						</aside>
					</section>
					
					<section>
						<h2>Comment atteindre 1ko ?</h2>
						<ol>
							<li class="fragment">Jouer sur la syntaxe JS</li>
							<li class="fragment">Faire bon usage des Maths</li>
							<li class="fragment">Utiliser des outils de minification/compression</li>
							<li class="fragment">Supprimer des fonctionnalités si nécéssaire</li>
							<li class="fragment">Répéter jusqu'à satisfaction</li>
						</ol>

						<aside class="notes">
							Par "atteindre", je veux dire "réduire jusqu'à", ne vous y trompez pas ! Car la concision n'est habituellement pas un soucis, et on a plus l'habitude de prendre ces aises.
							- Variables et fonction au nom explicite s'étalant sur 30 caractères
							- Espaces, retour à la ligne et indentation
							- Commentaires
							Autant de choses utiles (indispensables) lors de la phase de rédaction du code (juste, par exemple, pour être capable de se relire), mais qui deviennent le Mal quand on est limité à une poignée d'espace mémoire.
							Alors comment réduire tout ça, descendre sous le kilo-octet ?
							- En supprimant tout ce que je viens de citer. Plus d'espace ou de comm', 1 char par nom, ...
							- Puis en jouant sur la syntaxe JS. Il existe des tricks, des astuces que je vais vous présenter.
							- En jouant aussi sur des concepts mathématiques
							- Enfin, il existe des outils capables de recompiler votre code JS pour le minifier, voire le compresser.
							- Après, il reste la douloureuse solution de limiter son ambition, de rogner le code si durement implémenté ...
							- Et tout cela, vous êtes amenés à le répéter des dizaines, des centaines de fois, à chaque modif' de votre code, pour vous assurer du respect de la limite ...
							
						</aside>
					</section>
					
					<section>
						<h2>Syntaxe JS</h2>
						<p>Bible : <a href="">"Byte-saving Techniques"</a>,<br/>	wiki de la communauté <a href="http://www.140byt.es">140bytes</a></p>

						<aside class="notes">
							Donc, commençons par les astuces syntaxiques.
							Je ne vais vous en présenter que quelques unes, celles qui m'ont probablement été le plus utiles.
							Si vous voulez en connaitre plus, je vous invite à consulter ce wiki Github maintenu par la communautés 140bytes. Il s'agit d'une vraie Bible du JS minimaliste.
						</aside>
					</section>
					
					<section>
						<h3>Variables</h3>
						<ul>
							<li>
								<p>Adieu <code>var</code></p>
								<pre><code>var a=0; var b=0; // avant
a=b=0   	         // après</code></pre>
							</li>
							<li>
								<p>(ré)utiliser les paramètres de fonctions</p>
								<pre><code>function(a){var b=1;...} // avant
function(a,b){b=1;...}   // après</code></pre>
							</li>
							<li>
								<p>Se rappeler qu'assigner une valeur retourne celle-ci</p>
								<pre><code>a=this.prop;if(a){...} // avant
if(a=this.prop){...}   // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Tout d'abord les astuces touchant aux variables.
							J'ai déjà parlé de les renommer pour ne garder qu'un seul caractère. Mais les outils que je vous présenterai plus loin peuvent le faire automatiquement pour vous.
							Donc premièrement, dites adieu aux "var". Passez tout en global. C'est généralement unanimement déconseillé. Mais on parle là d'un script de seulement 1024o. Il ne s'agit pas d'un script parmi tant d'autres d'une lourde appli Web. Avec un minimum de prudence, ca ne devrait avoir aucun impact.
							
							Déclarer les variables est une perte d'espace. Il existe néanmoins diverses méthodes pour réduire cet impact.
							La 1ere : profiter des paramètres de fonctions.
							
							Enfin, il est utile de se rappeler que l'opération d'assigner une valeur à une variable retourne justement cette valeur. Profitez de cela pour faire d'une pierre deux coups autant que possible !
						</aside>
					</section>
					
					<section>
						<h3>Boucles</h3>
						<ul>
							<li>
								<p>Décrémenter si possible</p>
								<pre><code>for (i=0;i<10;i++) // avant
for (i=10;i--;)    // après</code></pre>
							</li>
							<li>
								<p><code>for</code> > <code>while</code></p>
								<pre><code>while(1);    // avant
for(;;);     // après

i=10;while(i--){...} // avant
for(i=10;i--;){...}  // après</code></pre>
							</li>
							<li>
								<p>Placer certaines expressions dans le corps du <code>for</code></p>
								<pre><code>for(i=10;i--;){foo(); bar()}	// avant
for(i=10;i--;bar(),foo());	// après
for(i=10;i--;bar())foo();	        // encore après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Ensuite les boucles. Ce genre de démos en contient forcément pas mal.
							
							Premièrement, décrémentez. Boucler par incrémentation, c'est trop mainstream. Et regardez, vous y gagner 3 caractères ! Et croyez moi, à un moment du concours, vous faites péter le champagne pour chaque octet gagné ...
							
							Sinon la principale chose à retenir, c'est que le "for" est votre meilleur ami. Si la syntaxe de son corps peut sembler lourde, elle permet pourtant de gagner de précieux octets, en offrant une maléabilité que ne possède pas while.
							
							Autre exemple du pouvoir de "for" : vous pouvez utiliser la dernière partie de son corps, appelée à chaque itération, pour y mettre certaines de vos expressions à itérer ! Vous économisez ainsi en délimitateurs, en utilisant ceux déjà imposés par la syntaxe de la boucle !
						</aside>
					</section>
					
					<section>
						<h3>Conditions</h3>
						<ul>
							<li>
								<p>En cas d'imbrications, penser aux ternaires</p>
								<pre><code>if(a){if(b)x=1;else x=2}else x=3;    // avant
x=a?b?1:2:3;                          // après</code></pre>
							</li>
							<li>
								<p>Tout simplement éviter les <code>if</code></p>
								<pre><code>if(a)foo()    // avant
a&&foo()      // après
 
if(!a)bar()   // avant
a||bar()      // après</code></pre>
							</li>
							<li>
								<p><code>^</code> pour tester l'inégalité de nombres</p>
								<pre><code>if(a!=123) // avant
if(a^123) // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Les conditions. Il existe tellement de syntaxes possibles. Il faut savoir bien les utiliser
							
							Exemple tout simple et pourtant tellement efficace : l'utilisation des expressions ternaires à la place d'usuels "if / else" ... 
							
							En fait, de manière générale, il faut tout faire pour éviter les "if", et je ne parle même pas des "else" ...
							Il existe des opérateurs pouvant très bien les remplacés.
							Si a est faux, foo() ne sera jamais appelé.
							Si a est vrai,bar() ne le sera pas.
							C'est très sale, encore une fois déconseillé, par forcément optimal niveau performance / optimisé par le moteur du navigateur, mais le gain de place est absolument non négligeable !
							
							Un dernier exemple prouvant que bien connaitre ses opérateurs est une nécessité. Une façon plus concise de tester l'inégalité numérique.
						</aside>
					</section>
					
					<section>
						<h3>Divers</h3>
						<ul>
							<li>Connaître la précédence des opérateurs</li>
							<li>
								<p>Profiter de la coercition des arrays</p>
								<pre><code>"rgb("+(x+8)+","+(y-20)+","+z+")"; // avant
"rgb("+[x+8,y-20,z]+")";           // après</code></pre>
							</li>
							<li><i>Inliner</i> au maximum (éviter constantes et fonctions)</li>
							<li>...</li>
						</ul>

						<aside class="notes">
							Quelques autres tricks en vrac ...
							
							Pour reparler de la maitrise des opérateurs ... Celle peut vous permettre d'économiser de la place en évitant des parenthèses inutiles / évitables.
							
							Autre astuce utile : quand joints avec une string, les arrays sont imprimés avec tous leurs éléments séparés par des virgules ... Très utile pour imprimer des couleurs.
							
							Enfin, un trick structurel : inliner autant que possible ! Le mot "function" est trop long pour être appelé sans raison, donc éviter de définir des centaines de fonctions.
							De même, au lieu de perdre de la place à définir des constantes, utilisez directement leur valeur (si elles sont courtes) ! Plus pénible à modifier/maintenir encore une fois, mais il ne faut rien négliger !
							Surtout que comme nous le verrons, les répétitions causées par ces "inlines" peuvent être nulifiées par les outils de compression.
							
							Pour plus d'astuces, vous reportez aux articles web cités ...
						</aside>
					</section>
					
					<section>
						<h2>Maths</h2>

						<aside class="notes">
							Les astuces mathématiques et numériques maintenant ...
						</aside>
					</section>
					
					<section>
						<h3>Nombres</h3>
						<ul>
							<li>
								<p>Arrondir / Tronquer sans utiliser <code>Math</code> (nb>0)</p>
								<pre><code>truncA = Math.floor(a); // avant
truncA = 0|a; 	       // après

roundA = Math.round(a); // avant
roundA = a+.5|0;        // après</code></pre>
							</li>
							<li>
								<p>Réduire les grands nombres</p>
								<pre><code>million=1000000 // avant
million=1e6     // après

dix=10          // avant
dix=9           // après (ca paaaaasse!)</code></pre>
							</li>
						</ul>

						<aside class="notes">
							L'expression des nombres. Il y a beaucoup à dire ici.
							Si l'objet JS "Math" offre de précieuses fonctions, leur appel prend de la place, un gaspillage quand parfois l'opération voulue peut être exprimée directement plus concisement.
							Un exemple avec l'opération d'arrondi ou de tronquage.
							Plus technique et approximatif : connaitre les limites et approximations des fonctions usuelles peut aussi s'avérer utile.
							Savoir que sin(x) ~= x pour les valeurs de x -> 0, ce genre de chose 
							Pour le coup, ca demande de bien connaitre les cas d'utilisation, les domaines de valeur, mais c'est parfois le cas (voire souvent puisqu'on ne veut pas de mauvaise surprise au sein de sa démo).
							
							Enfin, il est possible de jouer sur la notation des grands nombres. Un exemple pour les nombre décimaux.
							Pour les binaires, il est aussi possible d'utiliser les opérateur "<" ou ">".
							
							Alors le dernier exemple nécessite probablement une explication. Sachez déjà que cette utilisation est véridique. Cette approximation m'a fait gagner 2-3 précieux octets.
							J'utilisais la valeur 10 pour définir la hauteur moyenne des montagnes. En passant à 9, celles-ci paraissent légèrement moins escarpées, mais visuellement la différence est minime. Alors que 2-3 octets de gagner, c'est énorme comme gain !
							Le message derrière cet exemple, c'est aussi qu'il faut parfois faire preuve de souplesse ...
						</aside>
					</section>
						
					<section>
						<h3>Génération procédurale</h3>
						<small>Rien n'égale la capacité d'expression et de synthèse des Maths ...</small>
						<ul>
							<li>Interpolation</li>
							<li>Géométrie 3D & Transformations</li>
							<li>Conditions par modulo</li>
							<li>...</li>
						</ul>

						<aside class="notes">
							Pour conclure sur les maths ... Il s'agit vraiment de votre meilleur ami pour exprimer beaucoup avec peu.
							- En faisant bon usage de la géométrie
							- En évitant les opérations matricielles, et donc les arrays, en sachant linéariser et condenser vos calculs
							- En utilisant des modulos au lieu de formules conditionnelles
							- ...
							
							Un dernier exemple :
							Pour définir les transitions de couleur de mon paysage (mer bleue avec des reflets plus ou moins foncés, plage jaune, foret vertes avec ombrage, neige blanche, ...), j'avais une série de conditions ...
							"Si hauteur du point <= niveau de l'eau, alors couleur du point = bleu;
							 Si hauteur du point >~ noveau de l'eau, alors couleur = jaune sable"
							 ... pour chaque palié
							C'était long et verbeux. Et puis je me suis rappelé mes cours de Maths, et la notion d'interpolation.
							Après tout, là, mon gradient de couleur, c'est une fonction, exprimée par chaque point de mes conditions.
							En interpolant, il devrait être possible d'approximer en un seul polynome l'ensemble de la fonction !
							Je suis allé sur le site web Wolfgram Alpha, j'ai rentré mes coordonnées (niveau eau, bleu; niveau plage, jaune; ...) et il m'a retourné les possibles interpolations approximant le tout.
							Gain de place !
							
						</aside>
					</section>
					
					<section>
						<h2>Minifiers</h2>

						<aside class="notes">
							Bon, pour revenir sur du plus technique, je vais maintenant vous présenter d'intéressants outils
						</aside>
					</section>
					
					<section>
						<h3>Google Closure</h3>
						<p>Suite compilant du JS afin de l'optimiser et le compacter.</p>
						<a href="http://closure-compiler.appspot.com"><img src="img/closure.jpg" alt="Closure" width=800 /></a>

						<aside class="notes">
							Le premier est plutot connu, il s'agit de Google Closure. Il s'agit d'un outil que vous pouvez faire tourner sur votre PC ou utiliser en ligne.
							Il est avant tout connu pour recompiler du code JS afin de l'optimiser, en évitant les branches inutiles, ce genre de chose.
							Puis il compacte votre code, renommant les variables, supprimant les espaces, évitant les formulations inutiles...
							Il le compacte. Il le minifie.
						</aside>
					</section>
					
					<section>
						<h3>Traitement Post-Closure</h3>
						<ul>
							<li>
								<p>Supprimer les zéros inutiles</p>
								<pre><code>x=0.9 // avant
x=.9  // après</code></pre>
							</li>
							<li>
								<p>Supprimer le point-virgule final</p>
								<pre><code>foo();bar();voila(); // avant
foo();bar();voila()  // après</code></pre>

						<aside class="notes">
							Néanmoins, dans l'optique de gagner des caractères, il peut être nécessaire de repasser un peu derrière.
							Closure a tendance à remettre le zéro optionnel des nombres décimaux.
							Aussi, nul besoin du point-virgule final ...
							Mais autrement, il s'agit d'un précieux outil.
						</aside>
					</section>
					
					<section>
						<h3>JSCrush</h3>
						<p>Démo pour JS1K 2012 par <a href="https://twitter.com/aivopaas">@aivopaas</a></p>
						<p>Permet de compresser un code déjà minifié</p>
						<a href="http://www.iteral.com/jscrush"><img src="img/jscrush.jpg" alt="Closure" height=400; /></a>

						<aside class="notes">
							Mais votre meilleur ami, c'est JSCrush.
							Il s'agit en fait d'une démo codé pour JS1K 2012, qui depuis sert donc à coder les nouvelles démos ... Assez méta.
							Son créateur est aivopaas, un habitué du concours. Cet outil tient d'ailleurs en moins de 1000o. 972 il me semble.
							
							Et donc le pouvoir de cette application, c'est de compresser votre code déjà minifié.
						</aside>
					</section>
					
					<section>
						<h3>Comment JSCrush compresse:</h3>
							<ol>
								<li class="fragment"><p>Cherche le 1er char ASCII libre pour délimiter.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.log('Hello-lo!')</code>" &rarr; delim = "<code>X</code>"</p>
								</li>
								<li class="fragment"><p>Cherche les éléments répétitifs intéressants</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.log('Hello-lo!')</code>"&rarr; el = "<code>lo</code>" </p>
								</li>
								<li class="fragment"><p><i>Split</i> le code en utilisant 2 puis <i>join</i> avec 1.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.Xg('HelX-X!')</code>"</p>
								</li>
								<li class="fragment"><p>Ajoute 1+2 au code, et 1 dans une autre chaîne.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.Xg('HelX-X!')Xlo</code>", chaineDelim = "<code>X</code>"</p>
								</li>
								<li class="fragment"><p>Répète jusqu'à plus de gain ou de délim.</p></li>
							</ol>

						<aside class="notes">
							Par curiosité, regardons comment cela fonctionne.
							C'est en fait important de comprendre ce fonctionnement, car ca permet d'en faire le meilleur usage possible. Donc ...
							
							[Slide explicite]
							
							Néanmoins, pour rappel, les démos js1k doivent être self-containing. On ne peut pas faire d'appel extérieur.
							Donc impossible de lancer une appli externe pour décompresser la chaine obtenu.
							Mais la magie de JSCrush, c'est justement d'inclure ensuite un bootstrap, un p'tit morceau de JS qui décompressera et lancera votre programme.
						</aside>
							
					</section>
					
					<section>
						<h3>Comment JSCrush décompresse:</h3>
							<pre><code>for(Y in $=chaineDelim)with(code.split($[Y]))code=join(pop());eval(code)</code></pre>
							<p class="fragment">Pour chaque caractère de la chaîne de délimiteurs:</p>
							<ol>
								<li class="fragment">Le caractère est utilisé pour <i>split</i> le code.</li>
								<li class="fragment">Le dernier morceau est <i>pop</i>-é et utilisé pour <i>join</i> à nouveau le code.</li>
							</ol>

						<aside class="notes">
							Ce bootstrap, le voici. En vrai, "chaineDelim" est directement remplacée par son contenu. Et "code" est exprimé sur un seul char.
							Et ce que ce bootstrap fait donc, c'est [explicite].
						</aside>
					</section>
					
					<section>
						<h3>Créer des <i>patterns</i> pour JSCrush</h3>
						<ul>
							<li>
								<p>Limiter et réutiliser les variables intelligemment</p>
								<small>ex: si vous utilisez toujours <code>A</code> pour les arrays, et <code>i</code> pour les indices, alors <code>A[i]</code> sera <i>crushé</i>, faisant gagner 3n-7 octets (n nombre d'apparition de <code>A[i]</code>)</small>
							</li>
							<li>
								<p>Réarranger les expressions</p>
								<pre><code>m=i*r-9;q=r*j-9 // avant
m=i*r-9;q=j*r-9 //après - pattern "*r-9;"</code></pre>
							</li>
							<li>
								<p>Uniformiser les signatures de fonctions</p>
								<pre><code>x=function(a){...}, y=function(b,c){...}   // avant
x=function(b,c){...}, y=function(b,c){...} // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Maintenant, on sait donc que JSCrush tire son efficacité de la compressions des morceaux de codes répétitifs.
							Il faut donc chercher au maximum à créer des patterns dans son programme. Comment cela ?
							- En limitant les nouveaux noms, en réutilisant les variables crées. J'ai fait un p'tit calcul pour évaluer le gain que cela peut avoir pour l'expression des arrays ...
							
							- C'est intéressant aussi de réarranger dans la mesure du possible son code, pour faire apparaitre ces patterns.
							
							- Enfin, quelque chose qui du premier abord semble contreproductif : uniformiser les signatures des fonctions en prenant la plus longue comme pattern.
							Ainsi, l'ensemble "function" + tout ce qu'il y a entre parenthèse sera remplacé par un unique char. "function(...)" n'apparaitra plus qu'une fois dans votre code.
							
							JSCrush est donc un outil très puissant pour ce concours. Il génère un code complétement illisible et inmodifiable cependant !
							Il me semble que la quasi totalité des démos gagnantes l'ont utilisé ...
						</aside>
					</section>
					
					<section>
						<h3>RegPack</h3>
						<p>Outil basé sur JSCrush, un peu plus efficace</a></p>
						<p>Ajoute une étape à la compression :<br/><code>chaineDelim</code> est convertie en une regex plus compacte.</p>
						<a href="https://github.com/Siorki/RegPack">http://github.com/Siorki/RegPack</a>

						<aside class="notes">
							Cette année, Siorki, un des compétiteurs, développa un nouvel outil encore plus puissant.
							Basé sur JSCrush, il ajoute une 2nde étape à la compression destinées à exprimer la chaine de tokens sous forme de regex, bien plus courte.
							Il va surement faire fureur pour la prochaine session js1k ...
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Workflow</h1>

						<aside class="notes">
							A ce stade, il devient dur de gratter des octets supplémentaires. Etudions maintenant le workflow général.
							Celui que j'ai adopté, mais qui correspond à celui de pas mal d'autres compétiteurs .
						</aside>
					</section>
					
					<section>
						<h3>3 Phases</h3>
							<ol>
								<li class="fragment"><p><i>Enfance - L'Innocence</i></p>
									<p style="margin: 0 2em; font-size: .7em;">1ko ? Laaarge ! 1 ou 2 retouches et ce vieux projet devrait tenir !</p>
								</li>
								<li class="fragment"><p><i>Adolescence - La Rage & les Désillusions</i></p>
									<p style="margin: 0 2em; font-size: .7em;">1026 octets encore !!?? Bon ben tant pis pour la fonctionalité X...</p>
								</li>
								<li class="fragment"><p>Maturité - Le Perfectionnisme</p>
									<p style="margin: 0 2em; font-size: .7em;">J'hésite... Les reflets sur l'eau, tu les préfères en cos(7x+3) ou cos(9x+2)?</p></li>
							</ol>

						<aside class="notes">
							Ainsi, on est à peu près tous passé par 3 phases.
							D'abord on débarque dans le concours, la fleur au fusil. On voit pas trop ce qui pourrait mal se passer. Un peu de réécriture, de minification, et le tour devrait être joué.
							Pour moi, c'est quand j'ai débuté en voulant reprendre mon vieux code poussiéreux et verbeux ...
							
							Puis rapidement on se mange les dents. La désillusion. L'amertume. On reprend tout du début, mais là encore ca coince. On arrive pas à obtenir quelque chose de correct sur si peu de place.
							
							Mais doucement, imperceptiblement, par douloureux incréments, après moultes tentatives, ca commence à prendre forme. Le programme, comme nous, devient mature
							A la fin, les questions que je me posais, ce n'était plus "Je supprime quoi, le zoom ou le dégradé en fond ?", mais plutot "Quelle est la meilleure couleur pour la plage ?".
							Sur la fin, j'ouvrais plein de micro branches pour tester de légères modifications dans les couleurs, les formes, les interactions, ...
							Ca devenait du pur perfectionnisme, limite obsessionnel ...
							Tu connais tellement ton programme par coeur, c'est ton bébé ... Tu repousses le moment de couper le corde, de la soumettre enfin ...
							
						</aside>
							
					</section>
					
					<section>
						<h2>Phase 1</h2>

						<aside class="notes">
							Bref, revenons sur la phase 1.
						</aside>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Trouver un thème, une idée</li>
								<li>Etudier les démos des précédents concours</li>
								<li>Tester, expérimenter</li>
							</ol>

						<aside class="notes">
							Que faut-il normalement faire pour pas refaire mes erreurs / celle du débutant ?
							Déjà, il faut éviter de participer sans idée préalable de ce que l'on veut faire. Il faut un semblant d'idée, des bases.
							Autre point préalable, je conseille vivement de jeter un oeil aux précédentes démos, de lire les commentaires de leur créateurs. Beaucoup poste sur leur blogs des explications détaillées qui sont passionnantes. Même sans vouloir participer, si le sujet vous intéresse, c'est vraiment à lire.
							Enfin, expérimentez. Faites des p'tits tests, des mini-démos. Testez les notions séparemment. Moteur graphique, procédure de génération de terrain, déplacement de caméra, ... Attendez de maitriser suffisamment les concepts et leur implémentations avant de vous jeter dans l'arène.
						</aside>
							
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Se familiariser avec les diverses notions</li>
								<li>Avoir une idée de la démo visée</li>
							</ul>

						<aside class="notes">
							Donc les objectifs, comme dit ...
						</aside>
							
					</section>
					
					<section>
						<h2>Phase 2</h2>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Implémente une fonctionnalité (JS lisible)</li>
								<li>Teste</li>
								<li>Compresse, minifie, évalue l'espace restant/manquant</li>
								<li>Répète <i>(beaucoup)</i></li>
							</ol>

						<aside class="notes">
							La deuxième étape, la plus dure. C'est une boucle à répéter des centaines de fois. Implémente une fonctionnalité, teste, compresse, pleure parce que ca ne rentre pas, modifie, recommence.
							C'est long, c'est douloureux. J'ai planté mon navigateur des dizaines de fois, j'ai réécrit la même fonction des dizaines de fois jusqu'à obtenir le bon résultat, j'avais Closure et JSCrush en permanence ouvert, ...
						</aside>
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Avoir une démo pas trop dénudée sous les 1024o</li>
								<li>Ne pas craquer</li>
							</ul>

						<aside class="notes">
							C'est un processus qui mettra vos talents de dev, vos nerfs, votre patience à rude épreuve. Les améliorations apparaitront lentement, faut juste pas craquer.
						</aside>
					</section>
					
					<section>
						<h2>Phase 3</h2>

						<aside class="notes">
							Et un matin, vous ouvrirez votre projet et verrez que tout tient, et que ca ressemble à quelque chose. Après une bonne cuite méritée, vous vous rendrez cependant compte qu'il y a encore *moyen* d'améliorer ...
						</aside>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Cherche des <i>patterns</i>, optimise, modifie, tente des ajouts</li>
								<li>Teste</li>
								<li><span style="text-decoration:line-through">Compresse</span>, minifie, évalue l'espace restant/manquant</li>
								<li>Répète <i>(beaucoup)</i></li>
							</ol>
							
						<aside class="notes">
							Donc vous reprenez le processus devenu routine.
							Mais avec quelques modifs.
							Déjà, ce n'est plsu vraiment de l'implémentation, c'est plus des modifications, des p'tits tests.
							Et personnellement, sur la fin j'ai clairement arrêté d'utiliser CLosure.
							Pourquoi ? Plus besoin.
							Je bossais direct sur le code minifié. Je codais minifié.
							Déjà c'est un gain de temps car pas besoin de passer par cette recompilation.
							En plus, Closure, en recompilant le tout, à la facheuse tendance à modifier la structure du code.
							Pas des grosses choses, mais assez pour détruire les patterns soigneusement créés pour JSCrush. Donc au lieu de devoir les faire réapparaitre à chaque fois, ca devient plus simple d'arrêter Closure.
							Et puis ca gêne plus pour coder. A ce point-là, tu connais les ~1200 caractères de ton programme par coeur. (je vous parlais de TOC en début de présentation ...)
						</aside>
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Etre satisfait</li>
							</ul>

						<aside class="notes">
							Donc là, l'objectif, c'est juste de se faire plaisir, d'optimiser la chose, de pousser la limite, d'être satisfait.
							Et surtout de pas louper la deadline (31 Mars).
						</aside>
					</section>
					
					<section>
						<h2>Outils</h2>

						<aside class="notes">
							Pour compléter sur le workflow, parlons outils ...
							Qu'est-ce qu'utilisent les développeurs js1k ...
						</aside>
					</section>
					
					<section>
						<p>Personnellement, pas grand chose...</p>

						<aside class="notes">
							Voilà. Je boassais pas mal de facon nomade, je n'avais pas forcément accès à une distrib Linux, ...
							Donc pas de réel environnement de travail
						</aside>
					</section>
					
					<section>
						<ul>
							<li>notepad ou JSBin</li>
							<li>Chrome + Firefox + Opera</li>
							<li>Closure Online + JSCruch</li>
							<li>Git</li>
						</ul>

						<aside class="notes">
							Ca se résumait à la base de la base pour le Web développement.
							- Notepad++ ou Geany, parfois JSBin durant certaines phases où je testais vraiment souvent.
							- Les navigateurs Web requis
							- Et bien sûr en plus la suite pour la minification / compression.
						</aside>
					</section>
					
					<section>
						<p>... mais il existe des suites pouvant aider ...</p>

						<aside class="notes">
							Après, ca ne veut pas dire qu'il n'y a pas des outils plus adapté.
							Par exemple, certains camarades compétiteurs ont utilisé ...
						</aside>
					</section>
					
					<section>
						<ul>
							<li><a href="https://github.com/zz85/js1k-tools" >JS1k Tools</a> (Node scripts + Minify / Uglify + JSCrush)</li>
							<li><a href="http://gruntjs.com" >Grunt</a> pour automatiser le processus</li>
						</ul>

						<aside class="notes">
							 [explicite]
						</aside>
					</section>
					
				</section>

				<section>
					<section>
						<h1>Résultats</h1>

						<aside class="notes">
							Je passe avoir fait le tour du Workflow.
							Voyons maintenant les résultats de tout ce processus, pour les autres et pour moi-même.
						</aside>
					</section>
					
					<section>
						<h2>Mes démos</h2>

						<aside class="notes">
							Dans mon cas, j'ai posté 3 démos différentes.
						</aside>
					</section>
					<section>
						<h3>Démo alpha - <a href="http://aldream.net/demo#js1k-2013-loom" >Loom</a></h3>

						<aside class="notes">
							La première implémentée et soumise se dénommait Loom.
							Elle utilise une version modifiée de l'algo Diamond-Square pour la génération du terrain, et l'algo du Peintre pour l'impression en 2D.
							Le rendu et les controles sont clairement différent de ma démo finale ...
							Personnellement je trouvais qu'il manquait quelque chose, d'où le fait que j'ai continuer à expérimenter une fois celle-ci soumise ...
						</aside>
					</section>
					<section>
						<h3>Démo bis - <a href="http://aldream.net/demo#js1k-2013-morphose" >Morphose</a></h3>

						<aside class="notes">
							J'ai donc testé 2 pistes.
							Une où je modifiais l'algo de génération procédurale, pour tester de nouvelles formes.
							L'autre où je modifiais le moteur 2D pour tester de nouveaux rendus.
							Le résultat de la 1ere piste, c'est ma démo Morphose.
							Cette démo réutilise le même moteur de rendu, l'algo du Peintre. Mais elle représente ce coup-ci un mesh mélant de manière pseudo-aléatoire la géométrie d'un cube et d'une sphère.
							C'était très fun à coder, pas trop prise de tête.
							Ca ma aussi permis de me rendre compte de certaines différences dans la gestion de l'API du canvas parmi les navigateurs.
							J'ai du ajouter une condition quand la démo tourne sur Firefox ou Opéra, pour diviser par 4 le nombre de triangles, sinon ca ramait trop sur ceux-ci.
							Attention, je ne critique pas (vraiment) ces navigateurs. Pour gagner de la place, je n'ai pas forcément suivi les best-practices quant à l'utilisation du canvas, donc ...
						</aside>
					</section>
					<section>
						<h3>Démo finale - <a href="http://aldream.net/demo#js1k-2013-pointillism" >Pointillism</a></h3>

						<aside class="notes">
							Enfin, la version finale de ma démo paysagiste, Pointillism.
							Plus d'algo du peintre, mais une nouvelle méthode pontilliste, basé sur diverses choses : triangulation, interpolation barycentrique, z-buffering et échantillonnage par méthode de Monte-Carlo (inspirée par un article de Roman Cortes, un fameux js1kiste). Elle avait au final l'avantage d'être plus compact, d'où les ajouts dynamiques ...
						</aside>
					</section>
					
					<section>
						<h2>Evolution du code</h2>
						<img src="img/graphEvolDemo.jpg" src="Evolution du code" />

						<aside class="notes">
							Un résultat intéressant, c'est ce schéma montrant grossièrement l'évolution du programme au cours du temps.
							Vous voyez ma première tentative amenée à échouer, vite abandonnée ...
							Ma reprise à zéro, en travaillant par incrément ...
							Puis la longue phase de peaufinage ...
						</aside>
					</section>
					
					<section>
						<h2>Effet des étapes de compression</h2>

						<aside class="notes">
							Dernières métriques intéressantes, les effets des étapes de compression sur la taille du code ...
						</aside>
					</section>
					
					<section>
						<h3>Version jolie & documentée</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;">// Maps:
var mapWithWater=[], map=[], mapFaces=[],
dim = 2, 				// Size of our square matrix (dim = rows = cols)

SIZE = 20,				// Width of our whole square landscape
MID = SIZE/2,			// Mid-width, to place the origin
WATER_LVL = 6,			// Sea level
BEACH_LVL = 6.04,		// Beach level
SNOW_LVL_INC = 7,		// Snow level, subtracting the incline (Yeah, sounds strange. See the code lines)
sgmtLength = SIZE,		// Length of the sub-squares sides
h=8,					// Alterations amplitude

wHeight, wWidth, 		// Window dim.
angleYaw=angleHead = .6,// Camera orientation
cameraDistance = 20,	// Camera distance to the origin
wantMove = 0,			// To know which mode is used (3=moving, 0=displaying)
refreshPaint; 			// Generated by the setTimeOut to refresh the canvas.
map[0]=[2,4,9,8]; 		// Initial description of our height-map...

// Generating the landscape with an increasing level of details :
for(var l=1;l&lt;9;l++){ // Our most-detailed map (map[8]) will thus be a 257x257 matrix, which means 66049 elements / 131072 faces for our mesh. map[9] is kindda computable, but displaying it almost kills my browser though...
	// First we generate the new details by adding points using stochastic interpolation.
	var newDim=2*dim-1; // We want to add 1 new element between each couple of them, so the size will increase of dim-1.
	mapWithWater[l]=[];
	map[l]=[];
	h /= 2; // Every iteration, we reduce the "error" amplitude, to generate more subtle alterations.
	for (var i=newDim; i--;) for (var j=newDim; j--;) {
		// We thus populate the new map from the bottom right element to the top-left. It affects the way we evaluate some elements value if we want to do it in only one step: we can use all the values of the old matrix, but only the values of the new elements which has a bigger index than the current one.
		var iMap = i*newDim+j,
			iSMap= dim*(i&gt;&gt;1)+j/2|0; // Index of the top-left corner of the square in the smaller matrix.
		// JS trick: Math.floor(X) = 0|X if X positive, and X&gt;&gt;Y = 0|(X/(2*Y))
		map[l][iMap]=mapWithWater[l][iMap]=
			(i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 2  0  0		with X representing the current element, and the numbers those used to eval. it.
					// 0  X  1		It's kind of a mix between the midpoint displacement and the diamond-square algo: we try to reduce the artifacts 
					// 0  1  0		the 1st algo may generate, without the 2nd step required by the other.
					(mapWithWater[l][iMap+newDim] + mapWithWater[l][iMap+1] + 2*map[l-1][iSMap]) / 4
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(map[l-1][iSMap] + map[l-1][iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(map[l-1][iSMap] + map[l-1][iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					map[l-1][iSMap]
			) + h * (.6 - Math.random()); // And for each element, we add a small error to generate our random landscape. Our constant h controls the ampli. of this error. As h is divided by 2 every iteration, so is this coefficient. The first iterations thus generates the "rough geography" of our landscape while the last ones, with a smaller amplitude, add the details.
			mapWithWater[l][iMap] = (mapWithWater[l][iMap] &lt; WATER_LVL)? WATER_LVL:mapWithWater[l][iMap];// To get our flat water surface
	}

	// Then we make a mesh out of our height map: we take each square defining our map and cut them into 2 triangles, which will become 2 faces of our mesh. Each element, at the position (i,j) of our matrix and with the value z, will generate a 3D-vertex (X=i*r-A, Y=j*r-B, Z=z-C), with (A,B,C) the chosen origin (we take A=B=mapSize/2 and C=0, so the center of the map corresponds to the origin).
	// We also use this step to evaluate the color of the faces as we generate them, using their height and a rough evaluation of their inclination as parameters.
	dim=newDim--; // We do "newDim--" right now not to repeat "newDim-1" later.
	sgmtLength/=2; // We want to increase the level of details of our map, not its size. So with each it., we divide by 2 the distance separating the vertices.
	mapFaces[l]=[];
	var trId = 0;
	// As previously, we iterate desc. The idea is that for each element we iterate on, we evaluate the faces of the square which as for top-left corner this element. So we don't want to iterate on the last column and last row. We thus start at the prev. ones (reason why we decreased newDim by 1):
	for (var i=newDim; i--;) {
	// X --- o	Schema representing the faces extracted from a square. X is the current element.
	// |  \  |
	// o --- o
		for (j = newDim; j--;) for (k=2;k--;) { // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
			var elId = dim*i+j;
			mapFaces[l][trId] = [
				// 1st vertex
					m=i*sgmtLength-MID,
					q=j*sgmtLength-MID,
					mapWithWater[l][elId],
				// 2nd vertex - the one varying (either corresponding to the element on the next row, or the one on the next col). We use a modulo 2 on the face's id to select the good one.
					(i + k)*sgmtLength-MID, // (trId+1)%2 = k. And we don't mind which triangle we generate first, so k is cheaper.
					(j + 1-k)*sgmtLength-MID,
					mapWithWater[l][elId + 1 + k*newDim], // elId + ((trId%2)? 1 : dim) -&gt; elId + 1 + k*newDim
				// 3rd vertex
					m+sgmtLength, // m+sgmtLength = (i+1)*sgmtLength-MID
					q+sgmtLength, // q+sgmtLength = (j+1)*sgmtLength-MID
					mapWithWater[l][elId+dim+1]];
			// The following code is a personal mishmash to evaluate the color, found after much tweaking.
			// The basic idea was at least to represent:
			//		- the sea (blue), the vegetation (green), the snow (white), and some intermediate hues (alpine, meadow, beach,...)
			//		- the luminosity depending on the surface normal and sun position. Since computing the cross product costs too much bytes, only the face incline is used to evaluate it, relative to a fixed implicit sun position.
			// For that, the HSL color system is perfect, separating hue and lightness. And for free, by playing with the saturation, we can get some nice vegetation effects! Moreover, when setting "hsl(H,S%,L%)", the values H, S and L don't need to be rounded (would have cost us some bytes - Though I have to check if it influences the performances...).
			// So we use the face height (approximated using only 1 vertex), the slope (approximated as shown above), some tweaking, and voila!
			var z2 = mapFaces[l][trId][5],
				z3 = mapFaces[l][trId][8], 
				incli = (z2-z3)/sgmtLength; // Really cheap way to get a value proportional to the inclination, since we know the X and Y repartition is regular. At leat, by using the height of the 2nd vertex, we can get a different value for each face.
				incCoef = 2+incli, // The tweaking...
				zCol = z3 - incCoef; // Useful value to make the boundary snow/vegetation less obvious/more random, and more importantly to somehow reduce the melting-point for poorly-lighted faces. Or how to cheaply simulate the illumination effect on snow.
			mapFaces[l][trId].push('hsl('+[ // Using coercion for the ","
				99*( // Hue
					(WATER_LVL&lt;z2)? 6/z2 	// Greenish
					: 2 					// Blue
					),
				32*( // Saturation	
					(WATER_LVL&lt;z2)? incCoef*2/zCol	// Ground saturation: medium, depending on the incline|height, giving us different kinds of veget.
					: zCol							// Water saturation: high
					)+'%',
				30*( // Lightness
					(SNOW_LVL_INC&lt;zCol)? incCoef/.6		// Bright snow
					: (BEACH_LVL&lt;z2)? incCoef*incCoef/7	// Normal vegetation
					: (WATER_LVL&lt;z2)? incCoef/.6		// Bright sand
					: 2-Math.random()/3					// Water with random waves
					)
			]+'%)');
			trId++;
		}
	}
}
function Paint(){ // See my other demo for details
	a.fillRect(0, 0, wWidth=c.width=innerWidth-21,wHeight=c.height=innerHeight-21);
	wWidth/=2; // We don't divide the height, to emphasize it.
	var sCoord = [],
		m=-Math.cos(angleYaw),w=-Math.sin(angleYaw),o=Math.cos(angleHead),x=Math.sin(angleHead),
		wantMap = mapFaces[8-wantMove];
	for (l in wantMap) {
		sCoord[l] = []
		for (j = 9;j;) {
			var v=wantMap[l][--j]-cameraDistance*o, u=wantMap[l][--j]-cameraDistance*m, t=wantMap[l][--j]-cameraDistance*w;
			sCoord[l].push(z = o*v+ (k=m*u+w*t)*x,(v*x-o*k)/z*wHeight + wHeight,(w*u-m*t)/z*wWidth + wWidth);
		}
		sCoord[l][9] = mapFaces[8-wantMove][l][9]
	}
	sCoord.sort(function(H,S,L){return H[3]-S[3]}); // Sorting			
	for (l in sCoord) // I had to choose between only stroking the triangles, only filling them, or sacrificing another feature. I found the holes left by only stroking interesting, like a reminder of those which are part of the universe fabric. ;-)
		//a.fillStyle = 
		a.beginPath(a.strokeStyle=sCoord[l][9]),
		a.moveTo(sCoord[l][8], sCoord[l][7]),
		a.lineTo(sCoord[l][5], sCoord[l][4]),
		a.lineTo(sCoord[l][2], sCoord[l][1]),
		a.closePath(),
		//a.fill(),
		a.stroke()
	//refreshPaint=wantMove? setTimeout(Paint,16) : 0;
};
// onclick = function() { // We change the view mode on click.
//	clearTimeout(refreshPaint);
//	Paint(wantMove^=3);
//}
// Drag to move around:
onmousedown=function(){
	wantMove=3;
	clearInterval(refreshPaint); refreshPaint=setInterval(Paint,16);
} // We have to clear the Interval in the case the user release the click out of the body.
onmouseup=function(){
	wantMove=0;
	clearInterval(refreshPaint); Paint();
}
onmousemove = function(H) {	// We tie the mouse position with the camera orientation.
	angleYaw = 2*H.clientX/wWidth;
	angleHead = 2*H.clientY/wHeight
}
onmousewheel=onwheel = function(H) { // Zooming with the wheel, cross-browser solution
    cameraDistance += H.deltaY | -H.wheelDeltaY/40;
}
Paint();</code></pre>
						<p>10000 octets</p>

						<aside class="notes">
							Déjà vous avez ici une version "beautifiée" du code de la démo, avec du JS lisible, de l'indentation, des commentaires explicites ... Le concours nous invite à poster une telle version pour les lecteurs. Cette version est limitée à 10000 octets. J'ai été un peu short pour les commentaires du coup ;)
						</aside>
					</section>

					<section>
						<h3>Version intermédiaire</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;">d=[],g=[], D=[], r=R=20,Y=.6
		
// Generating the landscape with various levels of details :
g[T=l=0]=[o=2,4,Z=9,h=8]//.sort(function(){return .5-Math.random()}) // Initial description of our map : a hole, a bump, and some stuff between ...

for(;l&lt;8;){
	i=p = 2*o-1,d[++l] = [], g[l]=[], h /= 2
	for (; i--;)
		for (j=p; j--;
			v=g[l-1][u=o*(i/2|0)+j/2|0], w=i*p+j, g[l][w]=d[l][w] = (i%2?
				j%2? (d[l][w+p]+d[l][w+1]+2*v)/4:(v+g[l-1][u+o])/2:
				j%2? (v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),
			d[l][w]=d[l][w] &lt; 6?6:d[l][w]);
	//o=p,i=--p,
	o=i=p--,i--, // Smaller once jsCrushed
	r/=2,D[l] = [];
}
zBuffer = [];a.fillRect(0, 0, wid=c.width=innerWidth-17,hei=c.height=innerHeight-21), wid/=2;
	
setInterval(function(H,S,L){
	m=-Math.cos(Z),w=-Math.sin(Z),z=Math.cos(Y),x=Math.sin(Y);
	if (T==5) { zBuffer = [];a.fillRect(0, 0, wid=c.width=innerWidth-17,hei=c.height=innerHeight-21), wid/=2; }
	for (i = 0; i &lt; 1e4; i++) {
		U=Math.random()*20-r; V=Math.random()*20-r;
		U0=U/r+.5|0;V0=V/r+.5|0;
		UR=U/r%1;VR=V/r%1;
		//W=UR*VR*d[8][I=o*U0+V0]+(1-UR)*VR*d[8][I+o]+UR*(1-VR)*d[8][I+1]+(1-UR)*(1-VR)*d[8][I+o+1];
		W=UR&lt;VR;
		Nx = (d[8][I=o*U0+V0]-d[8][I+o*W+1-W])*(W?UR:VR);
		Ny = (d[8][I+o+1]-d[8][I+o*W+1-W])*(!W?VR:UR);

		W = d[8][o*U0+V0]-Nx+Ny;
		
		v=W-R*z, u=V-10-R*m, t=U-10-R*w,
		pZ = z*v+(k=m*u+w*t)*x;
		pY = (v*x-z*k)/pZ*hei + hei;
		pX = (w*u-m*t)/pZ*wid + wid;
		if (!zBuffer[J=pY*wid*2+pX] || (pZ &lt; zBuffer[J])) {
			zBuffer[J] = pZ;
			v=d[8][I+(o+1)*(UR+.5|0)];u=d[8][I+1];u-=t=2+(v-u)/r;
			a.fillStyle = "hsl("+[32*(6&lt;v?22/v:6),32*(6&lt;v?t*2/u:u)+"%",32*(6&lt;u-Math.sin(R/9)?t/.6:6.05&lt;v?t*t/7:6&lt;v?t:2-Math.random()/3)]+"%)";
			a.fillRect(pX, pY, 1, 1);
		}
    }
	//o=T?setTimeout(e,16):0
}, 16);
// onclick=function(H,S,L){clearTimeout(o),e(T^=3)}
onmousedown=function(f,n){T=5};
onmouseup=function(f,n){T=8};
onmousemove=function(H,S,L){if(T==5)Z=2*H.clientX/wid,Y=2*H.clientY/hei}
onmousewheel=onwheel=function(H,S,L){
    R+=H.deltaY|-H.wheelDeltaY/40} // Cross-browser solution, but to heavy ... Update: Now we can afford it! \o/</code></pre>
						<p>2061 octets</p>

						<aside class="notes">
							Ca c'est mon code tel quel en milieu-fin de phase 2. Les noms de variables ont déjà laissé place à leur version mono-caractères, mais l'indentation est toujours là ...
							Quelques comm' aussi pour m'y retrouver.
							2061 octets ...
						</aside>
					</section>

					<section>
						<h3>Version post-Closure</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">d=[];g=[];D=[];r=R=20;Y=.6;for(g[T=l=0]=[o=2,4,Z=9,h=8];8&gt;l;){i=p=2*o-1;d[++l]=[];g[l]=[];for(h/=2;i--;)for(j=p;j--;v=g[l-1][u=o*(i/2|0)+j/2|0],w=i*p+j,g[l][w]=d[l][w]=(i%2?j%2?(d[l][w+p]+d[l][w+1]+2*v)/4:(v+g[l-1][u+o])/2:j%2?(v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),d[l][w]=6&gt;d[l][w]?6:d[l][w]);o=i=p--;i--;r/=2;D[l]=[]}zBuffer=[];a.fillRect(0,0,wid=c.width=innerWidth-17,hei=c.height=innerHeight-21);wid/=2;setInterval(function(b,e,f){m=-Math.cos(Z);w=-Math.sin(Z);z=Math.cos(Y);x=Math.sin(Y);5==T&&(zBuffer=[],a.fillRect(0,0,wid=c.width=innerWidth-17,hei=c.height=innerHeight-21),wid/=2);for(i=0;1E4&gt;i;i++)if(U=20*Math.random()-r,V=20*Math.random()-r,U0=U/r+.5|0,V0=V/r+.5|0,UR=U/r%1,VR=V/r%1,W=UR&lt;VR,Nx=(d[8][I=o*U0+V0]-d[8][I+o*W+1-W])*(W?UR:VR),Ny=(d[8][I+o+1]-d[8][I+o*W+1-W])*(W?UR:VR),W=d[8][o*U0+V0]-Nx+Ny,v=W-R*z,u=V-10-R*m,t=U-10-R*w,pZ=z*v+(k=m*u+w*t)*x,pY=(v*x-z*k)/pZ*hei+hei,pX=(w*u-m*t)/pZ*wid+wid,!zBuffer[J=pY*wid*2+pX]||pZ&lt;zBuffer[J])zBuffer[J]=pZ,v=d[8][I+(o+1)*(UR+.5|0)],u=d[8][I+1],u-=t=2+(v-u)/r,a.fillStyle="hsl("+[32*(6&lt;v?22/v:6),32*(6&lt;v?2*t/u:u)+"%",32*(6&lt;u-Math.sin(R/9)?t/.6:6.05&lt;v?t*t/7:6&lt;v?t:2-Math.random()/3)]+"%)",a.fillRect(pX,pY,1,1)},16);onmousedown=function(b,e){T=5};onmouseup=function(b,e){T=8};onmousemove=function(b,e,f){5==T&&(Z=2*b.clientX/wid,Y=2*b.clientY/hei)};onmousewheel=onwheel=function(b,e,f){R+=b.deltaY|-b.wheelDeltaY/40}</code></pre>
						<p>1377 octets</p>

						<aside class="notes">
							Le même code, après être passé par Closure. Voyez le gain ...
						</aside>
					</section>

					<section>
						<h3>Version finale pre-JSCrush</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">d=[];g=[];X=R=r=22;Y=.6;g[J=k=l=0]=[T=o=2,5,Z=9,h=8];for(D=[];9&gt;l;){i=p=2*o-1;d=[];h/=2;for(g[++l]=[];i--;)for(j=p;j--;v=g[l-1][u=o*(i/2|0)+j/2|0],w=i*p+j,g[l][w]=d[w]=(i%2?j%2?(v*2+d[w+p]+d[w+1])/4:(v+g[l-1][u+o])/2:j%2?(v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),d[w]=6&gt;d[w]?6:d[w]);o=i=p--;i--;r/=2}g=[];a.fillRect(0,0,W=c.width=innerWidth-18,H=c.height=innerHeight-21),W/=2;setInterval(function(f){m=-Math.cos(Z),w=-Math.sin(Z),z=Math.cos(Y),x=Math.sin(Y),b=Math.cos(J/87);J%200*T||(g=[],a.fillRect(0,0,W=c.width=innerWidth-18,H=c.height=innerHeight-21),W/=2);for (j=1e4;j--;t=k-11-X*w,k=Math.random()*(R-2*r),i=l,l=k/r+.5|0,p=h,h=k/r%1,F=h&gt;p,F=d[u=o*i+l]+(d[u]-d[u+o*F+1-F])*(F?p:h)+(d[u+o+1]-d[u+o*F+1-F])*(!F?p:h),v=F-X*z-3,U=k-11-X*m,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I)/f*H+H,I=(w*U-m*t)/f*W+W,f+1&lt;g[p=v*2*W+I]||(g[p]=f,p=d[u+o+1],F-=t=2+(p-h*d[u]-(1-h)*d[u+o])*52,a.fillStyle="hsla("+[25*(6p?25/p+b/p*4:7),25*(6&lt;p?t*3/p:F)+"%",(u=25*(6&lt;F-b?t:5.2&lt;F?t*t/5:6.05&lt;p?t/p*2:6&lt;p?t:1.6+Math.random()*.8)+b*Math.cos(l/87)*Math.cos(i/47*Math.cos(f/3)+J/13)*17)+"%",.6]+")",a.fillRect(I,v,t=u/50+3-T,t)));++J},16);onmousedown=function(f){T=0};onmouseup=function(f){T=2};onmousemove=function(f){T||(Z=2*f.clientX/W,Y=f.clientY/H)};onmousewheel=onwheel=function(f){T||(X+=f.deltaY|-f.wheelDeltaY/87)}</code></pre>
						<p>1288 octets</p>

						<aside class="notes">
							Enfin, il s'agit ici de la version finale du code. Celle sur laquelle je codais mes dernières p'tites modifications. Plus besoin de Closure.
						</aside>
					</section>

					<section>
						<h3>Version finale post-JSCrush</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9&gt;l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6&gt;]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h&gt;p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)</code></pre>
						<p>1024 octets</p>

						<aside class="notes">
							... et la version soumise. 1024 octets tout pile.
						</aside>
					</section>

					<section>
						<small>... et si seulement j'avais découvert RegPack avant le dernier jour ...</small> 
					</section>
					<section>
						<h3>Version finale post-RegPack</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;white-space: -moz-pre-wrap;word-wrap: break-word;">for(_='Math.__sin(^)+QQ"%",PeltaYOF?p:hNeightC?tB*(A]=@a.fillRect(=innerj%2?(v])+1g[/87)function(f){=Td[u||(forf.client=k-11-X*wheel--;),=225A6&lt;d[w	+o]-*F-FAl-1][u=[];_random()_cos(;onmouse0,0,W=c.widthWidth-18,H=c.hCHC-21W/dgX=R=r2;Y=.6;J=k=l=0@[T=o,5,Z=9,h=8];(D9&gt;l;){i=p*o-1;dh/;(++l]i)(j=p;jv==oAi/2|0Qj/2|0],w=i*p+j,l][w@	@(i%2?*2+	+p]+	/4:(v++o/2:+/2:vQhAY-	@6&gt;	]?6:	;o=i=pir/}g;setInterval(m=-Zw=-^Zz=Yx=^Yb=J;J%200*Tg=[],); (j=1e4;jtw,k=AR-2*ri=l,l=k/r+.5|0,p=h,h=k/r%1,F=h&gt;p,F==o*i+l]+(NQ(!Nv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I)/f*H+H,I=(w*U-m*t)/f*W+W,f&lt;p=v*2*W+I]p@f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25/p+b/p*4:7pB*3/p:FP(u=F-bB:5.2&lt;FB*t/5:6.05&lt;pB/p*2:6&lt;pB:1.6+*.8Qb*l*i/47*f/3QJ/13)*17P.6]+")",I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}=onX+=f.dO|-f.DO}';g=/[-@-CN-Q^_]/.exec(_);)with(_.split(g))_=join(shift());eval(_)</code></pre>
						<p>1001 octets !!!</p>
					</section>
					
					<section>
						<img src="img/poker-face-meme.jpg" alt="Poker Face" /> 
					</section>

					<section>
						<h2>Classement</h2>

						<aside class="notes">
							Maintenant le résultat de manière générale ...
						</aside>
					</section>
					
					<section>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1555" >Strange crystals II</a>, de <a href="http://twitter.com/ehouais" >Philippe Deschaseaux</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1461" >Furbee</a>, de <a href="http://twitter.com/romancortes" >Roman Cortes</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1516" >3013 The 䕵 space-time fracture</a>, de <a href="http://twitter.com/p01" >Mathieu 'p01' Henri</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1558" >Synth Sphere</a>, de <a href="http://twitter.com/gleurop" >Noah Weninger</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1507" >Pointillism</a>, de <a href="http://twitter.com/b_aldream" >Benjamin Bill Planche</a> \o/</li>
								<li><a href="http://js1k.com/2013-spring/demo/1454" >3D City Tour</a>, de <a href="http://twitter.com/ehouais" >Jani Ylikangas</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1450" >Comanche</a>, de <a href="http://twitter.com/Siorki" >Siorki</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1376" >Color Factors</a>, de <a href="http://twitter.com/hugoware" >Pablo Caro</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1460" >Winter Wrap</a>, de <a href="http://twitter.com/veubeke" >Arne</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1431" >Psychedelic</a>, de <a href="http://twitter.com/ehouais" >Piotr Stosur</a></li>
							</ol>
					</section>
					
					<section>
						<h3>Zoom sur le podium</h3>
							<ol>
								<li><a href="http://twitter.com/ehouais" >Philippe Deschaseaux</a> - 2012 : 4ème</li>
								<li><a href="http://twitter.com/romancortes" >Roman Cortes</a> - 2012 : 2ème; 2010 : 1er</li>
								<li><a href="http://twitter.com/p01" >Mathieu 'p01' Henri</a> - 2012 : 3ème; 2011 : 2ème ;...</li>
							</ol>
							<p>Des démos qui ont instantanément fait l'unanimité.</p>
					</section>
					
					<section>
						<p>... mais encore plus impressionnant ...</p>
					</section>
					
					<section>
						<p>Ils ont pris le temps de rendre hommage à la démo de l'autre!</p>
					</section>
					
					<section>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1451" >Furbee</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1461" style="margin-right:.5em;">Furbee, get out of that tunnel ASAP!</a></li>
							</ol>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1459" >Strange crystals</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1555" >Strange crystals II</a></li>
							</ol>
					</section>
					
					<section>
						<h3>Analyse des démos primées</h3>
						<ul>
							<li class="fragment">Très visuelles (3D, détails, ...)</li>
							<li class="fragment">Peu d'interactions</li>
							<li class="fragment">Peu d'API HTML5</li>
						</ul>

						<aside class="notes">
							Très visuelles, car ca reste le manière moyen d'accrocher un badaud lambda, d'attirer l'attention ... Et puis le canavs est mis à disposition, c'est presque une invitation implicite ...
							
							Peu d'interactions, car ca prend de la place ! "onmousemove", "onclick", ... Des propriétés longues à écrire, des fonctions à coder pour chaque event, des comportements / objets event différents en fonction des browsers ... Décourageant.
							Et puis offrir du controle à l'utilisateur, c'est perdre du controle sur sa propre démo. Il vaut peut-être mieux être sûr que tout marche comme on le veut, que ca suive le scénario voulu.
							Pour vous donner une idée, plus de 10% de mon code - presque 150 octets - sont purement destinés aux controles ...
							
							Peu d'API. Pareil, trop longs d'appeler de telles fonctions, et un comportement pas forcément homogène.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Bilan</h1>

						<aside class="notes">
							Il est donc finalement temps de faire un bilan de tout ça ...
						</aside>
					</section>
					
					<section>
						<h2>Demoscene</h2>

						<aside class="notes">
							Je commencerai par dire que js1k est une extension, voire même s'inscrit dans le Demoscene.
							Qu'est-ce que cela ?
						</aside>
					</section>
					
					<section>
						<blockquote cite="http://wikipedia.com">Sous-culture informatique ayant pour but la création artistique sous forme de programme, fondée sur les trois domaines que sont : la musique assistée par ordinateur, l’infographie et la programmation.</blockquote>

						<aside class="notes">
							Vous avez peut-être entendu parlé de ces programmeurs et leur concours ... Des démos tenant sur 4, 16, 64ko, codées sur des disquettes à l'époque, pour des PC mais aussi des Amiga, des Commodore 64, ... A l'époque le matériel informatique en soit était la source de la limitation et donc du challenge.
							Aujourd'hui, cette limitation se retrouve sur le Web, sand-boxé. Pouet.net, js1K, jsgames13k, ...
							Le Web est devenu le nouveau far-west des programmeurs en quête de challenges.
						</aside>
					</section>
					
					<section>
						<p>Discipline pour <em>Hackers</em></p>

						<aside class="notes">
							Et donc ce genre de concours, selon moi, est organisés par et pour les Hackers.
							Dans le sens large du terme. Ceux qui recherchent l'astuce, le raccourcis, l'optimisation.
						</aside>
					</section>
					
					<section>
						<ul>
							<li>
								<p>Hacker le <strong>contenu</strong> du code</p>
								<code>Raccourcis langagiers, Mix d'algos, ...</code>
							</li>
							<li>
								<p>Hacker la <strong>forme</strong> du code</p>
								<code>Patterns, compressions, ...</code>
							</li>
						</ul>

						<aside class="notes">
							Pourquoi ? Parce que ce genre de challenge informatique requiert
							- De hacker le contenu du code. Le "faire beaucoup avec peu", avec toutes les astuces langagières ou mathématiques que l'on a vues.
							- Mais aussi de hacker la forme. De ne pas seulement voir ce que fait le code, mais comment est fait le code.
							C'est un domaine un peu méta, mais tellement intéressant et remplis de challenges. Compression des données, développement / lutter contre de programmes malicieux, ...
						</aside>
					</section>
					
					<section>
						<blockquote cite="http://www.joshuakoo.com/">Its like a marathon where its better to have weeks of preparations, but everyone's a winner when they finish. &mdash; Joshua Koo</blockquote>

						<aside class="notes">
							Pour revenir sur le concours js1k même, je citerai Joshua Koo, un camarade participant, car il a trouvé la formulation juste.
						</aside>
					</section>
					
					<section>
						<ul>
							<li>Du fun et des larmes</li>
							<li>Une manière de (re)découvrir la programmation</li>
							<li>Des rencontres sympas</li>
						</ul>

						<aside class="notes">
							Ce que ce concours apporte, au dela du prix et de la visibilité ...
							- Un beau challenge à se donner
							- Une belle manière d'en apprendre plus sur son langage favori
							- Et enfin l'occasion d'échanger avec des gens partageant votre passion très souvent bien plus experts que vous ...
						</aside>
					</section>
					
					<section>
						<blockquote cite="https://twitter.com/salamondani">IMHO best compression scheme: imagination+time+math skills. &mdash; Philippe Deschaseaux (gagnant)</blockquote>

						<aside class="notes">
							Le mot de la fin, je le laisse au gagnant. Il s'agit de l'extrait d'un de ses tweets, retweeté par pas mal de compétiteurs car c'est l'avis partagé ...
						</aside>
					</section>
				</section>
					
				<section>
					<h1>Références</h1>
					<ul>
						<li><strong>140byt.es</strong>, <em><a href="https://github.com/jed/140bytes/wiki/Byte-saving-techniques">Byte-saving Techniques</a></em></li>
						<li><strong>Nikhil</strong>, <em><a href="http://blog.nikhilism.com/2012/04/demystifying-jscrush.html">Demystifying JSCrush</a></em></li>
						<li><strong>Roman Cortes</strong>, <em><a href="http://www.romancortes.com/blog/">Blog</a> (description de ses démos)</em></li>
						<li><strong>Philippe Deschaseaux</strong>, <em><a href="http://dev.ehouais.net/js1k/">Blog</a> (description de ses démos)</em></li>
						<li><strong>Joshua Koo</strong>, <em><a href="http://www.lab4games.net/zz85/blog/">Blog</a> (description de ses démos)</em></li>
						<li>...</li>
					</ul>
					<small> Toutes les descriptions de démos sont intéressantes à lire. Voir <a href="http://js1k.com">js1k.com</a></small>
				</section>
				
				<section>
					<h2>Merci pour votre attention !</h1>
					<small><a href="https://twitter.com/b_aldream">@b_aldream</a> | <a href="https://github.com/Aldream">git:Aldream</a> | <a href="http://aldream.net">aldream.net</a></small>
				</section>

			</div>

		</div>

		<script src="reveal.js-2.6.1/lib/js/head.min.js"></script>
		<script src="reveal.js-2.6.1/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js-2.6.1/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js-2.6.1/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js-2.6.1/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js-2.6.1/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js-2.6.1/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js-2.6.1/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
