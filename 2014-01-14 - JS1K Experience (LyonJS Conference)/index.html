<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JS1K, Retour d'expérience | Benjamin (Bill) Planche</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>JS1K</h1>
					<h2>Retour d'expérience</h2>
					<p>
						<small>Par <a href="http://aldream.net">Benjamin (Bill) Planche</a><br/>
						Slides dispo sur <a href="https://github.com/Aldream/presentations">github.com/Aldream/presentations</a></small>
					</p>

					<aside class="notes">
						Présentation = Retour d'expérience sur le concours de prog JS1K.<br/>
						Si vous préférez suivre sur votre PC ou si vous voulez récup' les slides, direction Github.<br/>
						Maintenant, avant toute chose, j'aimerais vous présenter un bout de code et avoir votre avis dessus.
					</aside>
				</section>

				<section>
					<section>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; white-space: -moz-pre-wrap;word-wrap: break-word;">_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9>l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6>]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h>p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)</code></pre>
						<p>?</p>

						<aside class="notes">
							Qu'en pensez-vous ? Une idée du langage, de ce qu'il peut bien faire ?<br/>
							Même le colorateur syntaxique ne sait pas trop comment l'interprêter ...<br/>
							Quelques indices hein... conf' LyonJS, "eval", "join", "pop", "with" "setInterval", "hsla", ...<br/>
							Mais il y a aussi des aspects vraiment bizarres ...
						</aside>
					</section>
					<section>
						<h3>... et avec un peu plus de contexte ?</h3>
					</section>
					<section>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; font-size: 0.9em; white-space: -moz-pre-wrap;word-wrap: break-word;">&lt;!doctype html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;JS1k, 1k demo submission [ID]&lt;/title&gt;
		&lt;meta charset="utf-8" /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;canvas id="c"&gt;&lt;/canvas&gt;
		&lt;script&gt;
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit: http://qfox.nl/weblog/218
		&lt;/script&gt;
		&lt;script&gt;
// start of submission //
_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9&gt;l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6&gt;]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h&gt;p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)
// end of submission //
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>
						<p> ... ?</p>

						<aside class="notes">
							Au sein de la page web auquel il appartient. Aidé ... ? Un peu, mais pas des masses.<br/>
							JS autonome, aucun autre script chargé. Juste 3 déclarations. Page dépouillée.<br/>
							Code = longue string, d'où le eval final ...<br/>
							<br/>
							
							Présentation de la démo :<br/>
							- Une étendue d'eau, avec un jeu dynamique de lumières et reflets.<br/>
							- Une fine plage de sable blanc au bord de l'eau<br/>
							- Un massif verdoyant<br/>
							- Des sommets rocheux et enneigés<br/>
							Illumination - zones éclairées / ombragées en fonction de leur orient.<br/>
							Si vous rechargez la page, un nouveau paysage apparait. Il se dessine dynamiquement, par ajout de p'tits points de couleur.<br/>
							D'où le nom de cette démo, "Pointillism".<br/>
							Cette génération continue permet également d'ajouter une certain dynamique, utilisée pour simuler le passage des saisons :<br/>
							- Jaunissement de la foret<br/>
							- Descente de la neige.<br/>
							- Passage de nuage (ombres projetées)<br/>
							Enfin, il est possible d'interagir avec, de s'y déplacer. Rotation zoom ...<br/><br/>
							
							Bref, il s'agit donc de ma démo principale proposée pour le concours JS1K 2013. Et quelle est sa particularité ?
						</aside>
					</section>
					<section>
						<h2>1024 octets</h2>
						<p class="fragment">c'est peu.</p>

						<aside class="notes">
							Elle tient sur 1024 octets.
							Comme ça, c'est peut-être un peu dur à se représenter, mais 1024o ... c'est peu !
						</aside>
					</section>
					<section>
						<h3>Exemple</h3>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; white-space: -moz-pre-wrap;word-wrap: break-word;">
Ce programme Javascript permet de générer procéduralement des paysages. Ces paysages doivent contenir un relief assez montagneux, ainsi qu'une étendue d'eau. L'utilisateur doit pouvoir se déplacer dans la scène : il peut naviguer autour du paysage en maintenant le clic gauche de la souris et en déplaçant celle-ci, ou s'approcher / s'éloigner à l'aide de la molette. Le paysage se génère continuellement, par ajouts de petites tâches de couleur (plus grosses lors des déplacements pour obtenir plus rapidement un aperçu). A chaque chargement de la page, le contenu doit être différent (génération pseudo-aléatoire). La scène doit être suffisamment détaillée pour donner une impression de réalisme et d'étendue. Dans la même optique, la notion d'illumination doit être simulée, en obscurcissant les zones adéquates. Afin de correspondre au thème printanier du concours, une notion de défilement du temps doit être exprimée. On donnera donc l'impression du passage des saisons grâce à l...
						</code></pre>

						<aside class="notes">
							Pour donner une idée, mis l'écrit la description verbale de ma démo.<br/>
							En essayant d'éviter tout barratin, en restant concis et pro...<br/>
							Sur 1024 octets (caractères ici), pas pu faire tenir la moitié.
						</aside>
					</section>
					
					
					<section>
						<h2>Essence du concours JS1K :</h2>
						<p>Faire beaucoup avec peu</p>
						<p>Code minimaliste / immonde &rarr; Programme cool</p>
						

						<aside class="notes">
							Ce soucis de concision, c'est l'esprit même du concours JS1K.<br/>
							JS - Javascript, 1K - 1ko, ie 1024 octets, vous l'aurez compris ...<br/>
							But : pousser les programmeurs à faire beaucoup avec peu, à utiliser toute leur connaissance du langage, toute leur imagination et leur astuce pour réaliser quelque chose d'intéressant avec une forte contrainte d'espace.<br/>
							Et donc par la même occasion, de démontrer le pouvoir d'expression du JS ...<br/>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Avertissements !</h2>

						<aside class="notes">
							Dernière chose avant d'entrer enfin dans le vif du sujet ...
						</aside>
					</section>
					
					<section>
						<p>Le JS présenté ici n'est pas conforme W3C.</p>

						<aside class="notes">
							Premièrement, le code présenté est loin de se conformer à la plupart des règles de bonne pratique. <br/>
							Il n'est pas forcément cross-browser.<br/>
							Il n'est pas aisément maintenable, et carrément illisible.
						</aside>
					</section>
					
					<section>
						<p>A ne pas reproduire en entreprise.</p>

						<aside class="notes">
							Pour toutes ces raisons, je vous invite fortement à ne pas le reproduire en entreprise. Après je veux pas généraliser hein ...<br/>
							Mais j'aimerais pas être la personne (le stagiaire donc) chargée de maintenir ce genre de script ...
						</aside>
					</section>
					
					<section>
						<p>Peut entrainer TOC, insomnie et troubles de l'attention.</p>
						<p>Tenir hors de la portée et de la vue des programmeurs juniors.</p>
						<p>Ne pas dépasser la posologie conseillée.</p>
						<p>En cas d'effets indésirables, contactez votre lead-developer.</p>

						<aside class="notes">
							Enfin ... Par rapport au concours même ...<br/>
							Si vous songez à y participer un jour, soyez prévenus ... Vous allez y passer du temps et des larmes.<br/>
							Vous ne verrez probablement plus le JS de la même manière, et risquez d'attraper de très sales habitudes ...<br/><br/>
							Cela étant dit ...
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>JS1K</h1>

						<aside class="notes">
							Qu'est-ce que JS1K exactement ?
						</aside>
					</section>
					
					<section>
						<a href="http://js1k.com" title="JS1K"><img src="img/js1k.png" alt="JS1K logo" /></a>

						<aside class="notes">
							- Montrer le site Web -<br/><br/>
							
							Concours JS débuté en 2010par de Peter van der Zee (@kuvos), un web-dev néerlandais.<br/>
							Il y a déjà eu 5 sessions, à raison de 2 en 2012.<br/>
							Site très simple : Accueil, Règles, Liste<br/><br/>
							
							Jury = grands noms de la scène JS. Paul Irish, Juriy Zaytsev (Fabric.js), ...<br/>
							Prix = généreuses donation, et est réparti entre les X premiers<br/>
							10 démos nominées par le jur - postérité sur la page d'accueil.<br/>
							Pas THE concours qui vous fera connaitre dans le monde de la programmation, mais cela reste l'occasion de cotoyer des passionnés - plus ou moins influents -, et de malgré tout se faire un p'tit nom, au moins auprès de ceux-ci.
						</aside>
					</section>
					
					<section>
						<h2>Règlement</h2>
						
						<ul>
							<li class="fragment">Javascript, intégré au template html fourni</li>
							<li class="fragment">1024 octets max</li>
							<li class="fragment">Pas de ressources externes (lib, img, api, ...)</li>
							<li class="fragment">Cross-browser (récents)</li>
							<li class="fragment">Doit simplement fonctionner (au diable les best practices)</li>
						</ul>

						<aside class="notes">
							Les principales règles sont on-ne-peut-plus-simples :<br/>
							- JS pur, qui sera intégré dans le template fourni.<br/>
							- 1024o max, ofc<br/>
							- Le script doit fonctionné hors-connexion. Pas de ressources externes (même API)<br/>
							- Cross-browser autant que possible (Chrome, Firefox, Opera)<br/>
							- Rien à faire de la syntaxe et présentation. Ca doit marcher, point.<br/>
						</aside>
					</section>
					
					<section>
						<h2>Template (shim)</h2>
						<pre style="width: 800px; white-space: -moz-pre-wrap;word-wrap: break-word;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%; white-space: -moz-pre-wrap;word-wrap: break-word;">&lt;!doctype html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;JS1k, 1k demo submission [ID]&lt;/title&gt;
		&lt;meta charset="utf-8" /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;canvas id="c"&gt;&lt;/canvas&gt;
		&lt;script&gt;
			var b = document.body;
			var c = document.getElementsByTagName('canvas')[0];
			var a = c.getContext('2d');
			document.body.clientWidth; // fix bug in webkit
		&lt;/script&gt;
		&lt;script&gt;
// start of submission //
SCRIPT
// end of submission //
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</code></pre>

						<aside class="notes">
							Le Shim, le template que vous avez déjà pu observer auparavant.<br/>Page dénudée avec un simple canvas.<br/>Trois déclarations pouvant aider. Rien d'autre.<br/>
							Libre à vous de modifier le DOM, mais uniquement via le script JS (pas le droit de refermer la balise script pour ajouter du HTML.<br/>
						</aside>
						
					</section>
				</section>

				<section>
					<section>
						<h1>Mon Histoire</h1>

						<aside class="notes">
							Et moi dans tout ça, je suis quoi ?
						</aside>
					</section>
					
					<section>
						<h2>Qui suis-je ?</h2>
					</section>
					
					<section>
						<h3>Benjamin (Bill) Planche, aka Aldream</h3>
						<ul>
							<li>Etudiant INSA-Lyon</li>
							<li>Spécialités : Web, AI & CG</li>
						</ul>

						<aside class="notes">
							Benjamin Planche, plus communément nommé Bill. Pseudonyme Aldream sur le Web.<br/>
							INSA-Lyon<br/>
							Passionné par le Web depuis assez jeune. Aime aussi appliqué les maths ou l'art à l'informatique. J'ai eu l'occasion de bosser dans la robotique, le traitement d'image, la domotique, ...
						</aside>
					</section>
					
					<section>
						<h3>Contexte</h3>
						<ul>
							<li>Fan de JS1K sans jamais participer auparavant</li>
							<li>En année de césure quand JS1K 2013 a été annoncé</li>
							<li>Avais déjà tenté de traduire ce projet Matlab en JS</li>
						</ul>

						<aside class="notes">
							Découvert JS1K il y a 2 ans, durant session 2012. Regardé les choses de loin, sans m'imaginer tenter ...<br/>
							Année de césure. Malgré le boulot + act. exotiques, beaucoup de temps libre<br/>
							(re)pris l'habitude de coder pour le plaisir, des p'tits projets perso, mon site web, ...<br/>
							Commencé à me repencher sur un ancien projet. Pogramme JS traduit d'un projet Matlab, qui générait un simple paysage ...<br/>
						</aside>
					</section>
					
					<section>
						<h2>Elaboration</h2>
					</section>
					
					<section>
						<h3>Première Tentative</h3>
						<h4>ou comment je perdis 2 semaines et toute confiance</h4>
						<p class="fragment">Tenter de compresser un script JS codé auparavant</p>

						<aside class="notes">
							Quand la session 2013 de JS1K a été annoncé en le 1er Février, j'ai donc directement songé à ce projet.<br/>
							"Il suffirait de le minimiser, de supprimer le surplus, d'inliner certaines fonctions, de ne garder que le nécessaire des librairies utilisées, ..."<br/>
							Grave erreur.
						</aside>
					</section>
					
					<section>
						<h3>Pourquoi ce fut une erreur ?</h3>
						<ul>
							<li class="fragment">Buggé de base, mal structuré (erreurs de jeunesse...)</li>
							<li class="fragment">ET SURTOUT, pas adapté aux nouvelles contraintes</li>
						</ul>

						<aside class="notes">
							Pourquoi ?<br/>
							1 - Mon script était foireux de base. Mal codé, un peu buggé, ... Au moins rendu compte de mes progrès en programmation ...<br/>
							2 - SURTOUT, ce script n'avait pas été développé de base dans l'optique d'être compact.<br/>
							Et mine de rien, c'est une propriété qui devient intrasèque.<br/>
							Une telle démo doit être codée avec deux optiques : le but même de la démo, et le respect de la taille.<br/>
							Les deux sont à prendre autant en compte et influenceront tout autant la rédaction du code.<br/>
							Je l'ai compris après 10 jours à galérer ...
						</aside>
					</section>
					
					<section>
						<h3>Deuxième Tentative</h3>
						<h4>Partir de la Base</h4>
						<ul>
							<li class="fragment">Algo de visualisation 3D</li>
							<li class="fragment">Algo de génération procédurale</li>
						</ul>

						<aside class="notes">
							J'ai donc tout mis de côté, et je suis reparti du début.<br/>
							J'ai commencé par revoir les algos destinés à ce que je voulais faire, à les étudier en profondeur, à les comparer.<br/>
							(géométrie 3D, génération procédurale, transormations, fonctions stochastiques, interpolation, ...), on pourra en discuter après ou vous pourrez aller voir un article que j'ai fait. Ce n'est peut-être pas le sujet de cette conférence.<br/>
							Bref, je suis donc reparti de 0. J'ai tout recodé par incrément, jusqu'à satisfaction.<br/>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Compression</h1>

						<aside class="notes">
							En passant dnoc outre le contenu même du code, un aspect très important dans la création de ces démos, c'est la phase de minimisation / compression.<br/>
							Des techniques et des outils existent pour aider dans cette quête, qui ne se limitent pas au concours JS1K mais peuvent servir plus couramment ...
						</aside>
					</section>
					
					<section>
						<h2>Comment atteindre 1ko ?</h2>
						<ol>
							<li class="fragment">Jouer sur la syntaxe JS</li>
							<li class="fragment">Faire bon usage des Maths</li>
							<li class="fragment">Utiliser des outils de minification/compression</li>
							<li class="fragment">Supprimer des fonctionnalités si nécéssaire</li>
							<li class="fragment">Répéter jusqu'à satisfaction</li>
						</ol>

						<aside class="notes">
							Par "atteindre", je veux dire "réduire jusqu'à", ne vous y trompez pas ! Car la concision n'est habituellement pas un soucis, et on a plus l'habitude de prendre ces aises.<br/>
							- Variables et fonction au nom à rallonge, Espaces/indentation, Commentaires<br/><br/>
							-> choses utiles pour rédaction du code, mais le Mal quand on est limité<br/>
							Alors comment réduire tout ça, descendre sous le kilo-octet ?<br/>
							- En supprimant tout ce que j'ai de citer.<br/>
							- Syntaxe JS. Tricks, des astuces que je vais vous présenter.<br/>
							- En jouant aussi sur des concepts mathématiques<br/>
							- Outils capables de recompiler votre code JS pour le minifier / le compresser.<br/>
							- + douloureuse solution de limiter son ambition, de rogner le code si durement implémenté ...<br/>
							- à répéter des centaines de fois, à chaque modif' de votre code, pour vous assurer du respect de la limite ...<br/>
							
						</aside>
					</section>
					
					<section>
						<h2>Syntaxe JS</h2>
						<p>Bible : <a href="">"Byte-saving Techniques"</a>,<br/>	wiki de la communauté <a href="http://www.140byt.es">140bytes</a></p>

						<aside class="notes">
							Donc, commençons par les astuces syntaxiques.<br/><br/>
							Je ne vais vous en présenter que quelques unes, celles qui m'ont probablement été le plus utiles.<br/>
							Si vous voulez en connaitre plus, je vous invite à consulter ce wiki Github maintenu par la communautés 140bytes. Il s'agit d'une vraie Bible du JS minimaliste.<br/>
						</aside>
					</section>
					
					<section>
						<h3>Variables</h3>
						<ul>
							<li>
								<p>Adieu <code>var</code></p>
								<pre><code>var a=0; var b=0; // avant
a=b=0   	         // après</code></pre>
							</li>
							<li>
								<p>(ré)utiliser les paramètres de fonctions</p>
								<pre><code>function(a){var b=1;...} // avant
function(a,b){b=1;...}   // après</code></pre>
							</li>
							<li>
								<p>Se rappeler qu'assigner une valeur retourne celle-ci</p>
								<pre><code>a=this.prop;if(a){...} // avant
if(a=this.prop){...}   // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Renommer -> les outils que je vous présenterai peuvent le faire automatiquement<br/>
							Adieu "var". Passez tout en global. Généralement unanimement déconseillé. <br/>
							Mais script de seulement 1024o, pas d'une lourde appli Web.Si prudent, aucun impact.<br/><br/>
							
							Déclarer les variables = perte d'espace. Diverses méthodes pour réduire cet impact.<br/>
							La 1ere : profiter des paramètres de fonctions.<br/>
							
							Se rappeler : assigner une valeur la retourne justement. Profitez de cela pour faire d'une pierre deux coups autant que possible !<br/>
						</aside>
					</section>
					
					<section>
						<h3>Conditions</h3>
						<ul>
							<li>
								<p>En cas d'imbrications, penser aux ternaires</p>
								<pre><code>if(a){if(b)x=1;else x=2}else x=3;    // avant
x=a?b?1:2:3;                          // après</code></pre>
							</li>
							<li>
								<p>Tout simplement éviter les <code>if</code></p>
								<pre><code>if(a)foo()    // avant
a&&foo()      // après
 
if(!a)bar()   // avant
a||bar()      // après</code></pre>
							</li>
							<li>
								<p><code>^</code> pour tester l'inégalité de nombres</p>
								<pre><code>if(a!=123) // avant
if(a^123) // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Les conditions, tellement de syntaxes possibles. Il faut savoir bien les utiliser<br/>
							Exemple tout simple : expressions ternaires à la place d'usuels "if / else" ...<br/><br/> 
							
							Eviter les "if", et je ne parle même pas des "else" ... plein opérateurs pour les remplacer.<br/>
							Si a est faux, foo() ne sera jamais appelé, Si a est vrai,bar() ne le sera pas.<br/>
							Très sale, encore une fois déconseillé, par forcément optimal niveau performance / optimisé par le moteur du navigateur<br/><br/>
							
							Un dernier exemple prouvant que bien connaitre ses opérateurs est une nécessité. Une façon plus concise de tester l'inégalité numérique.
						</aside>
					</section>
					
					<section>
						<h3>Boucles</h3>
						<ul>
							<li>
								<p>Décrémenter si possible</p>
								<pre><code>for (i=0;i<10;i++) // avant
for (i=10;i--;)    // après</code></pre>
							</li>
							<li>
								<p><code>for</code> > <code>while</code></p>
								<pre><code>while(1);    // avant
for(;;);     // après

i=10;while(i--){...} // avant
for(i=10;i--;){...}  // après</code></pre>
							</li>
							<li>
								<p>Placer certaines expressions dans le corps du <code>for</code></p>
								<pre><code>for(i=10;i--;){foo(); bar()}	// avant
for(i=10;i--;bar(),foo());	// après
for(i=10;i--;bar())foo();	        // encore après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Boucler par incrémentation, trop mainstream.<br/><br/>
							
							Principale - "for" = meilleur ami. Syntaxe peut sembler lourde, mais offre + de maléabilité<br/><br/>
							
							Autre exemple du pouvoir de "for" : vous pouvez utiliser la dernière partie de son corps, appelée à chaque itération, pour y mettre certaines de vos expressions à itérer ! Vous économisez ainsi en délimitateurs, en utilisant ceux déjà imposés par la syntaxe de la boucle !
						</aside>
					</section>

					
					<section>
						<h3>Divers</h3>
						<ul>
							<li>Connaître la précédence des opérateurs</li>
							<li>
								<p>Profiter de la coercition des arrays</p>
								<pre><code>"rgb("+(x+8)+","+(y-20)+","+z+")"; // avant
"rgb("+[x+8,y-20,z]+")";           // après</code></pre>
							</li>
							<li><i>Inliner</i> au maximum (éviter constantes et fonctions)</li>
							<li>...</li>
						</ul>

						<aside class="notes">
							Maitrise des opérateurs ... Eviter parenthèses inutiles / évitables.<br/><br/>
							
							Quand joints avec string, arrays imprimés avec éléments séparés par des virgules.<br/><br/>
							
							Trick structurel : inliner autant que possible ! "function" = trop long<br/>
							Définir des constantes = pertes; utilisez directement leur valeur (si elles sont courtes) ! Plus pénible à modifier/maintenir encore une fois, mais il ne faut rien négliger !<br/>
							Surtout, les répétitions causées par ces "inlines" peuvent être nulifiées par les outils.<br/><br/>
							
							Pour plus d'astuces, vous reportez aux articles web cités ...
						</aside>
					</section>
					
					<section>
						<h2>Maths</h2>

						<aside class="notes">
							Les astuces mathématiques et numériques maintenant ...
						</aside>
					</section>
					
					<section>
						<h3>Nombres</h3>
						<ul>
							<li>
								<p>Arrondir / Tronquer sans utiliser <code>Math</code> (nb>0)</p>
								<pre><code>truncA = Math.floor(a); // avant
truncA = 0|a; 	       // après

roundA = Math.round(a); // avant
roundA = a+.5|0;        // après</code></pre>
							</li>
							<li>
								<p>Réduire les grands nombres</p>
								<pre><code>million=1000000 // avant
million=1e6     // après

dix=10          // avant
dix=9           // après (ca paaaaasse!)</code></pre>
							</li>
						</ul>

						<aside class="notes">
							L'expression des nombres. Il y a beaucoup à dire ici.<br/>
							"Math" offre de précieuses fonctions, mais appels = couteux<br/>Un gaspillage, parfois l'opération peut être exprimée plus concisement.<br/>
							Un exemple avec l'opération d'arrondi ou de tronquage.<br/>
							Plus technique et approximatif : connaitre les limites et approximations des fonctions usuelles<br/>
							sin(x) ~= x pour les valeurs de x -> 0, ce genre de chose <br/>
							Doit connaitre les cas d'utilisation, les domaines de valeur, mais puisqu'on veut pas de surprise au sein de sa démo.<br/><br/>
							
							EJouer sur la notation des grands nombres.<br/>
							Pour les binaires, il est aussi possible d'utiliser les opérateur "<" ou ">".<br/><br/>
							
							Utilisation est véridique. Cette approximation m'a fait gagner 2-3 précieux octets.<br/>
							J'utilisais la valeur 10 pour définir la hauteur moyenne des montagnes. En passant à 9, celles-ci paraissent légèrement moins escarpées, mais visuellement la différence est minime. Alors que 2-3 octets de gagner, c'est énorme comme gain !<br/>
							Le message derrière cet exemple, c'est aussi qu'il faut parfois faire preuve de souplesse ...
						</aside>
					</section>
						
					<section>
						<h3>Génération procédurale</h3>
						<small>Rien n'égale la capacité d'expression et de synthèse des Maths ...</small>
						<ul>
							<li>Interpolation</li>
							<li>Géométrie 3D & Transformations</li>
							<li>Conditions par modulo</li>
							<li>...</li>
						</ul>

						<aside class="notes">
							Pour conclure sur les maths ... Il s'agit vraiment de votre meilleur ami pour exprimer beaucoup avec peu.<br/>
							- En faisant bon usage de la géométrie<br/>
							- En évitant les opérations matricielles, et donc les arrays, en sachant linéariser et condenser vos calculs<br/>
							- En utilisant des modulos au lieu de formules conditionnelles<br/>
							- ...<br/><br/>
							
							Un dernier exemple :<br/>
							Pour définir les transitions de couleur de mon paysage (mer bleue avec des reflets plus ou moins foncés, plage jaune, foret vertes avec ombrage, neige blanche, ...), j'avais une série de conditions ...<br/>
							"Si hauteur du point <= niveau de l'eau, alors couleur du point = bleu;<br/>
							 Si hauteur du point >~ noveau de l'eau, alors couleur = jaune sable"<br/>
							 ... pour chaque palié<br/>
							C'était long et verbeux. Et puis je me suis rappelé mes cours de Maths, et la notion d'interpolation.<br/>
							Après tout, là, mon gradient de couleur, c'est une fonction, exprimée par chaque point de mes conditions.<br/>
							En interpolant, il devrait être possible d'approximer en un seul polynome l'ensemble de la fonction !<br/>
							Je suis allé sur le site web Wolfgram Alpha, j'ai rentré mes coordonnées (niveau eau, bleu; niveau plage, jaune; ...) et il m'a retourné les possibles interpolations approximant le tout.
							Gain de place !
							
						</aside>
					</section>
					
					<section>
						<h2>Minifiers</h2>

						<aside class="notes">
							Bon, pour revenir sur du plus technique, je vais maintenant vous présenter d'intéressants outils
						</aside>
					</section>
					
					<section>
						<h3>Google Closure</h3>
						<p>Suite compilant du JS afin de l'optimiser et le compacter.</p>
						<a href="http://closure-compiler.appspot.com"><img src="img/closure.jpg" alt="Closure" width=800 /></a>

						<aside class="notes">
							Outil connu. Tourne sur PC ou en ligne.<br/>
							Recompile du code JS afin de l'optimiser, en évitant les branches inutiles, ...<br/>
							Compacte votre code, renommant les var, supprimant les espaces, évitant les formulations inutiles...<br/>
							Il le compacte. Il le minifie.
						</aside>
					</section>
					
					<section>
						<h3>Traitement Post-Closure</h3>
						<ul>
							<li>
								<p>Supprimer les zéros inutiles</p>
								<pre><code>x=0.9 // avant
x=.9  // après</code></pre>
							</li>
							<li>
								<p>Supprimer le point-virgule final</p>
								<pre><code>foo();bar();voila(); // avant
foo();bar();voila()  // après</code></pre>

						<aside class="notes">
							Néanmoins, dans l'optique de gagner des caractères, il peut être nécessaire de repasser un peu derrière.<br/>
							Closure a tendance à remettre le zéro optionnel des nombres décimaux.<br/>
							Aussi, nul besoin du point-virgule final ...<br/>
							Mais autrement, il s'agit d'un précieux outil.<br/>
						</aside>
					</section>
					
					<section>
						<h3>JSCrush</h3>
						<p>Démo pour JS1K 2012 par <a href="https://twitter.com/aivopaas">@aivopaas</a></p>
						<p>Permet de compresser un code déjà minifié</p>
						<a href="http://www.iteral.com/jscrush"><img src="img/jscrush.jpg" alt="Closure" height=400; /></a>

						<aside class="notes">
							Mais votre meilleur ami, c'est JSCrush.<br/>
							Il s'agit en fait d'une démo codé pour JS1K 2012, qui depuis sert donc à coder les nouvelles démos ... Assez méta.<br/>
							Son créateur est aivopaas, un habitué du concours. Cet outil tient d'ailleurs en moins de 1000o. 972 il me semble.<br/>
							<br/>
							Et donc le pouvoir de cette application, c'est de compresser votre code déjà minifié.
						</aside>
					</section>
					
					<section>
						<h3>Comment JSCrush compresse:</h3>
							<ol>
								<li class="fragment"><p>Cherche le 1er char ASCII libre pour délimiter.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.log('Hello-lo!')</code>" &rarr; delim = "<code>X</code>"</p>
								</li>
								<li class="fragment"><p>Cherche les éléments répétitifs intéressants</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.log('Hello-lo!')</code>"&rarr; el = "<code>lo</code>" </p>
								</li>
								<li class="fragment"><p><i>Split</i> le code en utilisant 2 puis <i>join</i> avec 1.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.Xg('HelX-X!')</code>"</p>
								</li>
								<li class="fragment"><p>Ajoute 1+2 au code, et 1 dans une autre chaîne.</p>
									<p style="margin: 0 2em; font-size: .7em;">code = "<code>console.Xg('HelX-X!')Xlo</code>", chaineDelim = "<code>X</code>"</p>
								</li>
								<li class="fragment"><p>Répète jusqu'à plus de gain ou de délim.</p></li>
							</ol>

						<aside class="notes">
							Par curiosité, regardons comment cela fonctionne.<br/>
							C'est en fait important de comprendre ce fonctionnement, car ca permet d'en faire le meilleur usage possible. Donc ...<br/><br/>
							
							[Slide explicite]<br/><br/>
							
							Néanmoins, pour rappel, les démos js1k doivent être self-containing. On ne peut pas faire d'appel extérieur.<br/>
							Donc impossible de lancer une appli externe pour décompresser la chaine obtenu.<br/>
							Mais la magie de JSCrush, c'est justement d'inclure ensuite un bootstrap, un p'tit morceau de JS qui décompressera et lancera votre programme.
						</aside>
							
					</section>
					
					<section>
						<h3>Comment JSCrush décompresse:</h3>
							<pre><code>for(Y in $=chaineDelim)with(code.split($[Y]))code=join(pop());eval(code)</code></pre>
							<p class="fragment">Pour chaque caractère de la chaîne de délimiteurs:</p>
							<ol>
								<li class="fragment">Le caractère est utilisé pour <i>split</i> le code.</li>
								<li class="fragment">Le dernier morceau est <i>pop</i>-é et utilisé pour <i>join</i> à nouveau le code.</li>
							</ol>

						<aside class="notes">
							Ce bootstrap, le voici. En vrai, "chaineDelim" est directement remplacée par son contenu. Et "code" est exprimé sur un seul char.<br/>
							Et ce que ce bootstrap fait donc, c'est [explicite].
						</aside>
					</section>
					
					<section>
						<h3>Créer des <i>patterns</i> pour JSCrush</h3>
						<ul>
							<li>
								<p>Limiter et réutiliser les variables intelligemment</p>
								<small>ex: si vous utilisez toujours <code>A</code> pour les arrays, et <code>i</code> pour les indices, alors <code>A[i]</code> sera <i>crushé</i>, faisant gagner 3n-7 octets (n nombre d'apparition de <code>A[i]</code>)</small>
							</li>
							<li>
								<p>Réarranger les expressions</p>
								<pre><code>m=i*r-9;q=r*j-9 // avant
m=i*r-9;q=j*r-9 //après - pattern "*r-9;"</code></pre>
							</li>
							<li>
								<p>Uniformiser les signatures de fonctions</p>
								<pre><code>x=function(a){...}, y=function(b,c){...}   // avant
x=function(b,c){...}, y=function(b,c){...} // après</code></pre>
							</li>
						</ul>

						<aside class="notes">
							Donc JSCrush tire son efficacité de la compressions des morceaux de codes répétitifs.<br/>
							Il faut donc chercher au maximum à créer des patterns dans son programme. Comment cela ?<br/>
							- En limitant les nouveaux noms, en réutilisant les variables crées.<br/>
							
							- Réarranger si possible son code, pour faire apparaitre ces patterns.<br/><br/>
							
							- 1er abord contreproductif : uniformiser les signatures des fonctions en prenant la plus longue comme pattern.<br/>
							Ainsi, l'ensemble "function" + tout ce qu'il y a entre parenthèse sera remplacé par un unique char. "function(...)" n'apparaitra plus qu'une fois dans votre code.<br/><br/>
							
							JSCrush est donc un outil très puissant pour ce concours. Il génère un code complétement illisible et inmodifiable cependant !<br/>
							Il me semble que la quasi totalité des démos gagnantes l'ont utilisé ...
						</aside>
					</section>
					
					<section>
						<h3>RegPack</h3>
						<p>Outil basé sur JSCrush, un peu plus efficace</a></p>
						<p>Ajoute une étape à la compression :<br/><code>chaineDelim</code> est convertie en une regex plus compacte.</p>
						<a href="https://github.com/Siorki/RegPack">http://github.com/Siorki/RegPack</a>

						<aside class="notes">
							Cette année, Siorki, un des compétiteurs, développa un nouvel outil encore plus puissant.<br/>
							Basé sur JSCrush, 2nde étape à la compression destinées à exprimer la chaine de tokens sous forme de regex, bien plus courte.<br/>
							Il va surement faire fureur pour la prochaine session js1k ...
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Workflow</h1>

						<aside class="notes">
							A ce stade, il devient dur de gratter des octets supplémentaires. Etudions maintenant le workflow général.<br/>
							Celui que j'ai adopté, mais qui correspond à celui de pas mal d'autres compétiteurs .
						</aside>
					</section>
					
					<section>
						<h3>3 Phases</h3>
							<ol>
								<li class="fragment"><p><i>Enfance - L'Innocence</i></p>
									<p style="margin: 0 2em; font-size: .7em;">1ko ? Laaarge ! 1 ou 2 retouches et ce vieux projet devrait tenir !</p>
								</li>
								<li class="fragment"><p><i>Adolescence - La Rage & les Désillusions</i></p>
									<p style="margin: 0 2em; font-size: .7em;">1026 octets encore !!?? Bon ben tant pis pour la fonctionalité X...</p>
								</li>
								<li class="fragment"><p>Maturité - Le Perfectionnisme</p>
									<p style="margin: 0 2em; font-size: .7em;">J'hésite... Les reflets sur l'eau, tu les préfères en cos(7x+3) ou cos(9x+2)?</p></li>
							</ol>

						<aside class="notes">
							Ainsi, on est à peu près tous passé par 3 phases.<br/>
							D'abord on débarque dans le concours, la fleur au fusil. On voit pas trop ce qui pourrait mal se passer. Un peu de réécriture, de minification, et le tour devrait être joué.
							Pour moi, c'est quand j'ai débuté en voulant reprendre mon vieux code poussiéreux et verbeux ...<br/><br/>
							
							Puis rapidement on se mange les dents. La désillusion. L'amertume. On reprend tout du début, mais là encore ca coince. On arrive pas à obtenir quelque chose de correct sur si peu de place.<br/><br/>
							
							Mais doucement, imperceptiblement, par douloureux incréments, après moultes tentatives, ca commence à prendre forme. Le programme, comme nous, devient mature<br/>
							A la fin, les questions que je me posais, ce n'était plus "Je supprime quoi, le zoom ou le dégradé en fond ?", mais plutot "Quelle est la meilleure couleur pour la plage ?".<br/>
							Sur la fin, j'ouvrais plein de micro branches pour tester de légères modifications dans les couleurs, les formes, les interactions, ...<br/>
							Ca devenait du pur perfectionnisme, limite obsessionnel ...<br/>
							Tu connais tellement ton programme par coeur, c'est ton bébé ... Tu repousses le moment de couper le corde, de la soumettre enfin ...<br/>
							
						</aside>
							
					</section>
					
					<section>
						<h2>Phase 1</h2>

						<aside class="notes">
							Bref, revenons sur la phase 1.
						</aside>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Trouver un thème, une idée</li>
								<li>Etudier les démos des précédents concours</li>
								<li>Tester, expérimenter</li>
							</ol>

						<aside class="notes">
							Que faut-il faire pour pas refaire mes erreurs / celle du débutant ?<br/>
							Eviter de participer sans idée préalable de ce que l'on veut faire. Des bases.<br/>
							Jeter un oeil aux précédentes démos, de lire les commentaires de leur créateurs. Blogs.<br/>
							Expérimentez. p'tits tests, des mini-démos. Testez les notions séparemment. Moteur graphique, procédure de génération de terrain, déplacement de caméra, ...<br/>Attendez de maitriser suffisamment les concepts et leur implémentations avant de vous jeter dans l'arène.<br/>
						</aside>
							
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Se familiariser avec les diverses notions</li>
								<li>Avoir une idée de la démo visée</li>
							</ul>

						<aside class="notes">
							Donc les objectifs, comme dit ...
						</aside>
							
					</section>
					
					<section>
						<h2>Phase 2</h2>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Implémente une fonctionnalité (JS lisible)</li>
								<li>Teste</li>
								<li>Minifie, compresse, évalue l'espace restant/manquant</li>
								<li>Répète <i>(beaucoup)</i></li>
							</ol>

						<aside class="notes">
							La deuxième étape, la plus dure.<br/>C'est une boucle à répéter des centaines de fois. Implémente une fonctionnalité, teste, compresse, pleure parce que ca ne rentre pas, modifie, recommence.<br/>
							C'est long, c'est douloureux. J'ai planté mon navigateur des dizaines de fois, j'ai réécrit la même fonction des dizaines de fois jusqu'à obtenir le bon résultat, j'avais Closure et JSCrush en permanence ouvert, ...
						</aside>
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Avoir une démo pas trop dénudée sous les 1024o</li>
								<li>Ne pas craquer</li>
							</ul>

						<aside class="notes">
							C'est un processus qui mettra vos talents de dev, vos nerfs, votre patience à rude épreuve. Les améliorations apparaitront lentement, faut juste pas craquer.
						</aside>
					</section>
					
					<section>
						<h2>Phase 3</h2>

						<aside class="notes">
							Et un matin, vous ouvrirez votre projet et verrez que tout tient, et que ca ressemble à quelque chose.<br/>Après une bonne cuite méritée, vous vous rendrez cependant compte qu'il y a encore *moyen* d'améliorer ...
						</aside>
					</section>
					
					<section>
						<h3>Etapes</h3>
							<ol>
								<li>Cherche des <i>patterns</i>, optimise, modifie, tente des ajouts</li>
								<li>Teste</li>
								<li><span style="text-decoration:line-through">Minifie</span>, compresse, évalue l'espace restant/manquant</li>
								<li>Répète <i>(beaucoup)</i></li>
							</ol>
							
						<aside class="notes">
							Donc vous reprenez le processus devenu routine. Mais avec quelques modifs.<br/>
							Plus de l'implémentation, des modifications, des p'tits tests.<br/>
							Et personnellement, sur la fin j'ai clairement arrêté d'utiliser CLosure.<br/>
							Pourquoi ? Plus besoin.<br/>
							Je bossais direct sur le code minifié. Je codais minifié.<br/>
							Gain de temps car pas besoin de passer par cette recompilation.<br/>
							Facheuse tendance à modifier la structure du code -> patterns<br/>
							Tu connais les ~1200 caractères de ton programme par coeur. (je vous parlais de TOC en début de présentation ...)
						</aside>
					</section>
					
					<section>
						<h3>Objectifs</h3>
							<ul>
								<li>Etre satisfait</li>
							</ul>

						<aside class="notes">
							Donc là, l'objectif, c'est juste de se faire plaisir, d'optimiser la chose, de pousser la limite, d'être satisfait.<br/>
							Et surtout de pas louper la deadline (31 Mars).
						</aside>
					</section>
					
					<section>
						<h2>Outils</h2>

						<aside class="notes">
							Pour compléter sur le workflow, parlons outils ...<br/>
							Qu'est-ce qu'utilisent les développeurs js1k ...
						</aside>
					</section>
					
					<section>
						<p>Personnellement, pas grand chose...</p>

						<aside class="notes">
							Voilà. Je boassais pas mal de facon nomade, je n'avais pas forcément accès à une distrib Linux, ...<br/>
							Donc pas de réel environnement de travail
						</aside>
					</section>
					
					<section>
						<ul>
							<li>notepad ou JSBin</li>
							<li>Chrome + Firefox + Opera</li>
							<li>Closure Online + JSCruch</li>
							<li>Git</li>
						</ul>

						<aside class="notes">
							Ca se résumait à la base de la base pour le Web développement.<br/>
							- Notepad++ ou Geany, parfois JSBin durant certaines phases où je testais vraiment souvent.<br/>
							- Les navigateurs Web requis<br/>
							- Et bien sûr en plus la suite pour la minification / compression.
						</aside>
					</section>
					
					<section>
						<p>... mais il existe des suites pouvant aider ...</p>

						<aside class="notes">
							Après, ca ne veut pas dire qu'il n'y a pas des outils plus adapté.<br/>
							Par exemple, certains camarades compétiteurs ont utilisé ...
						</aside>
					</section>
					
					<section>
						<ul>
							<li><a href="https://github.com/zz85/js1k-tools" >JS1k Tools</a> (Node scripts + Minify / Uglify + JSCrush)</li>
							<li><a href="http://gruntjs.com" >Grunt</a> pour automatiser le processus</li>
						</ul>

						<aside class="notes">
							 [explicite]
						</aside>
					</section>
					
				</section>

				<section>
					<section>
						<h1>Résultats</h1>

						<aside class="notes">
							Je passe avoir fait le tour du Workflow.<br/>
							Voyons maintenant les résultats de tout ce processus, pour les autres et pour moi-même.
						</aside>
					</section>
					
					<section>
						<h2>Mes démos</h2>

						<aside class="notes">
							Dans mon cas, j'ai posté 3 démos différentes.
						</aside>
					</section>
					<section>
						<h3>Démo alpha - <a href="http://aldream.net/demo#js1k-2013-loom" >Loom</a></h3>

						<aside class="notes">
							La première implémentée et soumise se dénommait Loom.<br/>
							Elle utilise une version modifiée de l'algo Diamond-Square pour la génération du terrain, et l'algo du Peintre pour l'impression en 2D.<br/>
							Le rendu et les controles sont clairement différent de ma démo finale ...<br/>
							Personnellement je trouvais qu'il manquait quelque chose, d'où le fait que j'ai continuer à expérimenter une fois celle-ci soumise ...
						</aside>
					</section>
					<section>
						<h3>Démo bis - <a href="http://aldream.net/demo#js1k-2013-morphose" >Morphose</a></h3>

						<aside class="notes">
							J'ai donc testé 2 pistes.<br/><br/>
							Une où je modifiais l'algo de génération procédurale, pour tester de nouvelles formes.<br/>
							L'autre où je modifiais le moteur 2D pour tester de nouveaux rendus.<br/><br/>
							Le résultat de la 1ere piste, c'est ma démo Morphose.<br/>
							Cette démo réutilise le même moteur de rendu, l'algo du Peintre. Mais elle représente ce coup-ci un mesh mélant de manière pseudo-aléatoire la géométrie d'un cube et d'une sphère.<br/>
							C'était très fun à coder, pas trop prise de tête.<br/>
							Ca ma aussi permis de me rendre compte de certaines différences dans la gestion de l'API du canvas parmi les navigateurs.<br/>
							J'ai du ajouter une condition quand la démo tourne sur Firefox ou Opéra, pour diviser par 4 le nombre de triangles, sinon ca ramait trop sur ceux-ci.<br/>
							Attention, je ne critique pas (vraiment) ces navigateurs. Pour gagner de la place, je n'ai pas forcément suivi les best-practices quant à l'utilisation du canvas, donc ...
						</aside>
					</section>
					<section>
						<h3>Démo finale - <a href="http://aldream.net/demo#js1k-2013-pointillism" >Pointillism</a></h3>

						<aside class="notes">
							Enfin, la version finale de ma démo paysagiste, Pointillism.<br/>
							Plus d'algo du peintre, mais une nouvelle méthode pontilliste, basé sur diverses choses : triangulation, interpolation barycentrique, z-buffering et échantillonnage par méthode de Monte-Carlo (inspirée par un article de Roman Cortes, un fameux js1kiste).<br/>Elle avait au final l'avantage d'être plus compact, d'où les ajouts dynamiques ...
						</aside>
					</section>
					
					<section>
						<h2>Evolution du code</h2>
						<img src="img/graphEvolDemo.jpg" src="Evolution du code" />

						<aside class="notes">
							Un résultat intéressant, c'est ce schéma montrant grossièrement l'évolution du programme au cours du temps.<br/>
							Vous voyez ma première tentative amenée à échouer, vite abandonnée ...<br/>
							Ma reprise à zéro, en travaillant par incrément ...<br/>
							Puis la longue phase de peaufinage ...
						</aside>
					</section>
					
					<section>
						<h2>Effet des étapes de compression</h2>

						<aside class="notes">
							Dernières métriques intéressantes, les effets des étapes de compression sur la taille du code ...
						</aside>
					</section>
					
					<section>
						<h3>Version jolie & documentée</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;">// Maps:
var mapWithWater=[], map=[], mapFaces=[],
dim = 2, 				// Size of our square matrix (dim = rows = cols)

SIZE = 20,				// Width of our whole square landscape
MID = SIZE/2,			// Mid-width, to place the origin
WATER_LVL = 6,			// Sea level
BEACH_LVL = 6.04,		// Beach level
SNOW_LVL_INC = 7,		// Snow level, subtracting the incline (Yeah, sounds strange. See the code lines)
sgmtLength = SIZE,		// Length of the sub-squares sides
h=8,					// Alterations amplitude

wHeight, wWidth, 		// Window dim.
angleYaw=angleHead = .6,// Camera orientation
cameraDistance = 20,	// Camera distance to the origin
wantMove = 0,			// To know which mode is used (3=moving, 0=displaying)
refreshPaint; 			// Generated by the setTimeOut to refresh the canvas.
map[0]=[2,4,9,8]; 		// Initial description of our height-map...

// Generating the landscape with an increasing level of details :
for(var l=1;l&lt;9;l++){ // Our most-detailed map (map[8]) will thus be a 257x257 matrix, which means 66049 elements / 131072 faces for our mesh. map[9] is kindda computable, but displaying it almost kills my browser though...
	// First we generate the new details by adding points using stochastic interpolation.
	var newDim=2*dim-1; // We want to add 1 new element between each couple of them, so the size will increase of dim-1.
	mapWithWater[l]=[];
	map[l]=[];
	h /= 2; // Every iteration, we reduce the "error" amplitude, to generate more subtle alterations.
	for (var i=newDim; i--;) for (var j=newDim; j--;) {
		// We thus populate the new map from the bottom right element to the top-left. It affects the way we evaluate some elements value if we want to do it in only one step: we can use all the values of the old matrix, but only the values of the new elements which has a bigger index than the current one.
		var iMap = i*newDim+j,
			iSMap= dim*(i&gt;&gt;1)+j/2|0; // Index of the top-left corner of the square in the smaller matrix.
		// JS trick: Math.floor(X) = 0|X if X positive, and X&gt;&gt;Y = 0|(X/(2*Y))
		map[l][iMap]=mapWithWater[l][iMap]=
			(i%2?
				j%2?// Element on an odd row and odd col: it corresponds to a square center, so we populate it as shown in the following ascii schema:
					// 2  0  0		with X representing the current element, and the numbers those used to eval. it.
					// 0  X  1		It's kind of a mix between the midpoint displacement and the diamond-square algo: we try to reduce the artifacts 
					// 0  1  0		the 1st algo may generate, without the 2nd step required by the other.
					(mapWithWater[l][iMap+newDim] + mapWithWater[l][iMap+1] + 2*map[l-1][iSMap]) / 4
					
				:	// Element on an odd row and even col: we give it the avg of the elements on the prev. and next cols:
					// 1  0  0		Example
					// X  0  0
					// 1  0  0
					(map[l-1][iSMap] + map[l-1][iSMap+dim]) / 2
			:
				j%2?// Element on an even row and odd col: we give it the avg of the elements on the prev. and next rows:
					// 1  X  1		Example
					// 0  0  0
					// 0  0  0
					(map[l-1][iSMap] + map[l-1][iSMap+1]) / 2
				:	// Element on an even row and even col: it's one of the square corners, so we just give it the orig. val.:
					map[l-1][iSMap]
			) + h * (.6 - Math.random()); // And for each element, we add a small error to generate our random landscape. Our constant h controls the ampli. of this error. As h is divided by 2 every iteration, so is this coefficient. The first iterations thus generates the "rough geography" of our landscape while the last ones, with a smaller amplitude, add the details.
			mapWithWater[l][iMap] = (mapWithWater[l][iMap] &lt; WATER_LVL)? WATER_LVL:mapWithWater[l][iMap];// To get our flat water surface
	}

	// Then we make a mesh out of our height map: we take each square defining our map and cut them into 2 triangles, which will become 2 faces of our mesh. Each element, at the position (i,j) of our matrix and with the value z, will generate a 3D-vertex (X=i*r-A, Y=j*r-B, Z=z-C), with (A,B,C) the chosen origin (we take A=B=mapSize/2 and C=0, so the center of the map corresponds to the origin).
	// We also use this step to evaluate the color of the faces as we generate them, using their height and a rough evaluation of their inclination as parameters.
	dim=newDim--; // We do "newDim--" right now not to repeat "newDim-1" later.
	sgmtLength/=2; // We want to increase the level of details of our map, not its size. So with each it., we divide by 2 the distance separating the vertices.
	mapFaces[l]=[];
	var trId = 0;
	// As previously, we iterate desc. The idea is that for each element we iterate on, we evaluate the faces of the square which as for top-left corner this element. So we don't want to iterate on the last column and last row. We thus start at the prev. ones (reason why we decreased newDim by 1):
	for (var i=newDim; i--;) {
	// X --- o	Schema representing the faces extracted from a square. X is the current element.
	// |  \  |
	// o --- o
		for (j = newDim; j--;) for (k=2;k--;) { // We iterate 2 times for each square in order to generate the 2 corresponding triangle-faces.
			var elId = dim*i+j;
			mapFaces[l][trId] = [
				// 1st vertex
					m=i*sgmtLength-MID,
					q=j*sgmtLength-MID,
					mapWithWater[l][elId],
				// 2nd vertex - the one varying (either corresponding to the element on the next row, or the one on the next col). We use a modulo 2 on the face's id to select the good one.
					(i + k)*sgmtLength-MID, // (trId+1)%2 = k. And we don't mind which triangle we generate first, so k is cheaper.
					(j + 1-k)*sgmtLength-MID,
					mapWithWater[l][elId + 1 + k*newDim], // elId + ((trId%2)? 1 : dim) -&gt; elId + 1 + k*newDim
				// 3rd vertex
					m+sgmtLength, // m+sgmtLength = (i+1)*sgmtLength-MID
					q+sgmtLength, // q+sgmtLength = (j+1)*sgmtLength-MID
					mapWithWater[l][elId+dim+1]];
			// The following code is a personal mishmash to evaluate the color, found after much tweaking.
			// The basic idea was at least to represent:
			//		- the sea (blue), the vegetation (green), the snow (white), and some intermediate hues (alpine, meadow, beach,...)
			//		- the luminosity depending on the surface normal and sun position. Since computing the cross product costs too much bytes, only the face incline is used to evaluate it, relative to a fixed implicit sun position.
			// For that, the HSL color system is perfect, separating hue and lightness. And for free, by playing with the saturation, we can get some nice vegetation effects! Moreover, when setting "hsl(H,S%,L%)", the values H, S and L don't need to be rounded (would have cost us some bytes - Though I have to check if it influences the performances...).
			// So we use the face height (approximated using only 1 vertex), the slope (approximated as shown above), some tweaking, and voila!
			var z2 = mapFaces[l][trId][5],
				z3 = mapFaces[l][trId][8], 
				incli = (z2-z3)/sgmtLength; // Really cheap way to get a value proportional to the inclination, since we know the X and Y repartition is regular. At leat, by using the height of the 2nd vertex, we can get a different value for each face.
				incCoef = 2+incli, // The tweaking...
				zCol = z3 - incCoef; // Useful value to make the boundary snow/vegetation less obvious/more random, and more importantly to somehow reduce the melting-point for poorly-lighted faces. Or how to cheaply simulate the illumination effect on snow.
			mapFaces[l][trId].push('hsl('+[ // Using coercion for the ","
				99*( // Hue
					(WATER_LVL&lt;z2)? 6/z2 	// Greenish
					: 2 					// Blue
					),
				32*( // Saturation	
					(WATER_LVL&lt;z2)? incCoef*2/zCol	// Ground saturation: medium, depending on the incline|height, giving us different kinds of veget.
					: zCol							// Water saturation: high
					)+'%',
				30*( // Lightness
					(SNOW_LVL_INC&lt;zCol)? incCoef/.6		// Bright snow
					: (BEACH_LVL&lt;z2)? incCoef*incCoef/7	// Normal vegetation
					: (WATER_LVL&lt;z2)? incCoef/.6		// Bright sand
					: 2-Math.random()/3					// Water with random waves
					)
			]+'%)');
			trId++;
		}
	}
}
function Paint(){ // See my other demo for details
	a.fillRect(0, 0, wWidth=c.width=innerWidth-21,wHeight=c.height=innerHeight-21);
	wWidth/=2; // We don't divide the height, to emphasize it.
	var sCoord = [],
		m=-Math.cos(angleYaw),w=-Math.sin(angleYaw),o=Math.cos(angleHead),x=Math.sin(angleHead),
		wantMap = mapFaces[8-wantMove];
	for (l in wantMap) {
		sCoord[l] = []
		for (j = 9;j;) {
			var v=wantMap[l][--j]-cameraDistance*o, u=wantMap[l][--j]-cameraDistance*m, t=wantMap[l][--j]-cameraDistance*w;
			sCoord[l].push(z = o*v+ (k=m*u+w*t)*x,(v*x-o*k)/z*wHeight + wHeight,(w*u-m*t)/z*wWidth + wWidth);
		}
		sCoord[l][9] = mapFaces[8-wantMove][l][9]
	}
	sCoord.sort(function(H,S,L){return H[3]-S[3]}); // Sorting			
	for (l in sCoord) // I had to choose between only stroking the triangles, only filling them, or sacrificing another feature. I found the holes left by only stroking interesting, like a reminder of those which are part of the universe fabric. ;-)
		//a.fillStyle = 
		a.beginPath(a.strokeStyle=sCoord[l][9]),
		a.moveTo(sCoord[l][8], sCoord[l][7]),
		a.lineTo(sCoord[l][5], sCoord[l][4]),
		a.lineTo(sCoord[l][2], sCoord[l][1]),
		a.closePath(),
		//a.fill(),
		a.stroke()
	//refreshPaint=wantMove? setTimeout(Paint,16) : 0;
};
// onclick = function() { // We change the view mode on click.
//	clearTimeout(refreshPaint);
//	Paint(wantMove^=3);
//}
// Drag to move around:
onmousedown=function(){
	wantMove=3;
	clearInterval(refreshPaint); refreshPaint=setInterval(Paint,16);
} // We have to clear the Interval in the case the user release the click out of the body.
onmouseup=function(){
	wantMove=0;
	clearInterval(refreshPaint); Paint();
}
onmousemove = function(H) {	// We tie the mouse position with the camera orientation.
	angleYaw = 2*H.clientX/wWidth;
	angleHead = 2*H.clientY/wHeight
}
onmousewheel=onwheel = function(H) { // Zooming with the wheel, cross-browser solution
    cameraDistance += H.deltaY | -H.wheelDeltaY/40;
}
Paint();</code></pre>
						<p>10000 octets</p>

						<aside class="notes">
							Déjà vous avez ici une version "beautifiée" du code de la démo, avec du JS lisible, de l'indentation, des commentaires explicites ...<br/>Le concours nous invite à poster une telle version pour les lecteurs. Cette version est limitée à 10000 octets.<br/>J'ai été un peu short pour les commentaires du coup ;)
						</aside>
					</section>

					<section>
						<h3>Version intermédiaire</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;">d=[],g=[], D=[], r=R=20,Y=.6
		
// Generating the landscape with various levels of details :
g[T=l=0]=[o=2,4,Z=9,h=8]//.sort(function(){return .5-Math.random()}) // Initial description of our map : a hole, a bump, and some stuff between ...

for(;l&lt;8;){
	i=p = 2*o-1,d[++l] = [], g[l]=[], h /= 2
	for (; i--;)
		for (j=p; j--;
			v=g[l-1][u=o*(i/2|0)+j/2|0], w=i*p+j, g[l][w]=d[l][w] = (i%2?
				j%2? (d[l][w+p]+d[l][w+1]+2*v)/4:(v+g[l-1][u+o])/2:
				j%2? (v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),
			d[l][w]=d[l][w] &lt; 6?6:d[l][w]);
	//o=p,i=--p,
	o=i=p--,i--, // Smaller once jsCrushed
	r/=2,D[l] = [];
}
zBuffer = [];a.fillRect(0, 0, wid=c.width=innerWidth-17,hei=c.height=innerHeight-21), wid/=2;
	
setInterval(function(H,S,L){
	m=-Math.cos(Z),w=-Math.sin(Z),z=Math.cos(Y),x=Math.sin(Y);
	if (T==5) { zBuffer = [];a.fillRect(0, 0, wid=c.width=innerWidth-17,hei=c.height=innerHeight-21), wid/=2; }
	for (i = 0; i &lt; 1e4; i++) {
		U=Math.random()*20-r; V=Math.random()*20-r;
		U0=U/r+.5|0;V0=V/r+.5|0;
		UR=U/r%1;VR=V/r%1;
		//W=UR*VR*d[8][I=o*U0+V0]+(1-UR)*VR*d[8][I+o]+UR*(1-VR)*d[8][I+1]+(1-UR)*(1-VR)*d[8][I+o+1];
		W=UR&lt;VR;
		Nx = (d[8][I=o*U0+V0]-d[8][I+o*W+1-W])*(W?UR:VR);
		Ny = (d[8][I+o+1]-d[8][I+o*W+1-W])*(!W?VR:UR);

		W = d[8][o*U0+V0]-Nx+Ny;
		
		v=W-R*z, u=V-10-R*m, t=U-10-R*w,
		pZ = z*v+(k=m*u+w*t)*x;
		pY = (v*x-z*k)/pZ*hei + hei;
		pX = (w*u-m*t)/pZ*wid + wid;
		if (!zBuffer[J=pY*wid*2+pX] || (pZ &lt; zBuffer[J])) {
			zBuffer[J] = pZ;
			v=d[8][I+(o+1)*(UR+.5|0)];u=d[8][I+1];u-=t=2+(v-u)/r;
			a.fillStyle = "hsl("+[32*(6&lt;v?22/v:6),32*(6&lt;v?t*2/u:u)+"%",32*(6&lt;u-Math.sin(R/9)?t/.6:6.05&lt;v?t*t/7:6&lt;v?t:2-Math.random()/3)]+"%)";
			a.fillRect(pX, pY, 1, 1);
		}
    }
	//o=T?setTimeout(e,16):0
}, 16);
// onclick=function(H,S,L){clearTimeout(o),e(T^=3)}
onmousedown=function(f,n){T=5};
onmouseup=function(f,n){T=8};
onmousemove=function(H,S,L){if(T==5)Z=2*H.clientX/wid,Y=2*H.clientY/hei}
onmousewheel=onwheel=function(H,S,L){
    R+=H.deltaY|-H.wheelDeltaY/40} // Cross-browser solution, but to heavy ... Update: Now we can afford it! \o/</code></pre>
						<p>2061 octets</p>

						<aside class="notes">
							Ca c'est mon code tel quel en milieu-fin de phase 2. Les noms de variables ont déjà laissé place à leur version mono-caractères, mais l'indentation est toujours là ...<br/>
							Quelques comm' aussi pour m'y retrouver.<br/>
							2061 octets ...
						</aside>
					</section>

					<section>
						<h3>Version post-Closure</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">d=[];g=[];D=[];r=R=20;Y=.6;for(g[T=l=0]=[o=2,4,Z=9,h=8];8&gt;l;){i=p=2*o-1;d[++l]=[];g[l]=[];for(h/=2;i--;)for(j=p;j--;v=g[l-1][u=o*(i/2|0)+j/2|0],w=i*p+j,g[l][w]=d[l][w]=(i%2?j%2?(d[l][w+p]+d[l][w+1]+2*v)/4:(v+g[l-1][u+o])/2:j%2?(v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),d[l][w]=6&gt;d[l][w]?6:d[l][w]);o=i=p--;i--;r/=2;D[l]=[]}zBuffer=[];a.fillRect(0,0,wid=c.width=innerWidth-17,hei=c.height=innerHeight-21);wid/=2;setInterval(function(b,e,f){m=-Math.cos(Z);w=-Math.sin(Z);z=Math.cos(Y);x=Math.sin(Y);5==T&&(zBuffer=[],a.fillRect(0,0,wid=c.width=innerWidth-17,hei=c.height=innerHeight-21),wid/=2);for(i=0;1E4&gt;i;i++)if(U=20*Math.random()-r,V=20*Math.random()-r,U0=U/r+.5|0,V0=V/r+.5|0,UR=U/r%1,VR=V/r%1,W=UR&lt;VR,Nx=(d[8][I=o*U0+V0]-d[8][I+o*W+1-W])*(W?UR:VR),Ny=(d[8][I+o+1]-d[8][I+o*W+1-W])*(W?UR:VR),W=d[8][o*U0+V0]-Nx+Ny,v=W-R*z,u=V-10-R*m,t=U-10-R*w,pZ=z*v+(k=m*u+w*t)*x,pY=(v*x-z*k)/pZ*hei+hei,pX=(w*u-m*t)/pZ*wid+wid,!zBuffer[J=pY*wid*2+pX]||pZ&lt;zBuffer[J])zBuffer[J]=pZ,v=d[8][I+(o+1)*(UR+.5|0)],u=d[8][I+1],u-=t=2+(v-u)/r,a.fillStyle="hsl("+[32*(6&lt;v?22/v:6),32*(6&lt;v?2*t/u:u)+"%",32*(6&lt;u-Math.sin(R/9)?t/.6:6.05&lt;v?t*t/7:6&lt;v?t:2-Math.random()/3)]+"%)",a.fillRect(pX,pY,1,1)},16);onmousedown=function(b,e){T=5};onmouseup=function(b,e){T=8};onmousemove=function(b,e,f){5==T&&(Z=2*b.clientX/wid,Y=2*b.clientY/hei)};onmousewheel=onwheel=function(b,e,f){R+=b.deltaY|-b.wheelDeltaY/40}</code></pre>
						<p>1377 octets</p>

						<aside class="notes">
							Le même code, après être passé par Closure. Voyez le gain ...
						</aside>
					</section>

					<section>
						<h3>Version finale pre-JSCrush</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">d=[];g=[];X=R=r=22;Y=.6;g[J=k=l=0]=[T=o=2,5,Z=9,h=8];for(D=[];9&gt;l;){i=p=2*o-1;d=[];h/=2;for(g[++l]=[];i--;)for(j=p;j--;v=g[l-1][u=o*(i/2|0)+j/2|0],w=i*p+j,g[l][w]=d[w]=(i%2?j%2?(v*2+d[w+p]+d[w+1])/4:(v+g[l-1][u+o])/2:j%2?(v+g[l-1][u+1])/2:v)+h*(Y-Math.random()),d[w]=6&gt;d[w]?6:d[w]);o=i=p--;i--;r/=2}g=[];a.fillRect(0,0,W=c.width=innerWidth-18,H=c.height=innerHeight-21),W/=2;setInterval(function(f){m=-Math.cos(Z),w=-Math.sin(Z),z=Math.cos(Y),x=Math.sin(Y),b=Math.cos(J/87);J%200*T||(g=[],a.fillRect(0,0,W=c.width=innerWidth-18,H=c.height=innerHeight-21),W/=2);for (j=1e4;j--;t=k-11-X*w,k=Math.random()*(R-2*r),i=l,l=k/r+.5|0,p=h,h=k/r%1,F=h&gt;p,F=d[u=o*i+l]+(d[u]-d[u+o*F+1-F])*(F?p:h)+(d[u+o+1]-d[u+o*F+1-F])*(!F?p:h),v=F-X*z-3,U=k-11-X*m,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I)/f*H+H,I=(w*U-m*t)/f*W+W,f+1&lt;g[p=v*2*W+I]||(g[p]=f,p=d[u+o+1],F-=t=2+(p-h*d[u]-(1-h)*d[u+o])*52,a.fillStyle="hsla("+[25*(6p?25/p+b/p*4:7),25*(6&lt;p?t*3/p:F)+"%",(u=25*(6&lt;F-b?t:5.2&lt;F?t*t/5:6.05&lt;p?t/p*2:6&lt;p?t:1.6+Math.random()*.8)+b*Math.cos(l/87)*Math.cos(i/47*Math.cos(f/3)+J/13)*17)+"%",.6]+")",a.fillRect(I,v,t=u/50+3-T,t)));++J},16);onmousedown=function(f){T=0};onmouseup=function(f){T=2};onmousemove=function(f){T||(Z=2*f.clientX/W,Y=f.clientY/H)};onmousewheel=onwheel=function(f){T||(X+=f.deltaY|-f.wheelDeltaY/87)}</code></pre>
						<p>1288 octets</p>

						<aside class="notes">
							Enfin, il s'agit ici de la version finale du code. Celle sur laquelle je codais mes dernières p'tites modifications.<br/>Plus besoin de Closure.
						</aside>
					</section>

					<section>
						<h3>Version finale post-JSCrush</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;word-wrap: break-word;">_='dgX=R=r2;Y=.6;JL=l=0&[TN,5,Z=9,h=8];(D9&gt;l;){i=p*oO;dh/;(++l]i)(j=p;jv=	N@iP|0jP|0],w=i*p+j,l][w&&(i%2?*2++p]+/4:(v+	+oP:+	P:vh@Y-&6&gt;]?6:;o=i=pir/}g;setInterval(m=-Zw=-KZz=Yx=KYb=J;J%290*Tg=[],); (j=1e4;jtw,k=@R-2*ri=l,lL/r+.5|0,p=h,hL/r%1,F=h&gt;p,F=N*i+l]+(C(!Cv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I^H+H,I=(w*U-m*t^W+W,f&lt;p=v*2*W+I]p&f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25Q+bQ*4:7pA*3Q:FG(u=F-bA:5.2&lt;FA*t/5:6.05&lt;pAQ*2:6&lt;pA:1.6+*.8b*l*i/47*f/3J/13)*17G.6]+")",$I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}NnX+=f.dE|-f.DE}$0,0,W=c.wV#WVO8,H=c.hB#HB-21W/function(f){Math.;onmousecos(+orandom()=[];	lO][u]-*F-F@d[wa.fill25@6&lt;=2),--;wheelLO1-X*f.client)+for||(d[u=T/87)g[+1])j%2?(v#=inner$Rect(&]=@*(A?tBeightCF?p:hEeltaYG"%",Ksin(L=kN=oO-1P/2Q/pVidth^)/f*';for(Y in $='^VQPONLKGECBA@&$#	')with(_.split($[Y]))_=join(pop());eval(_)</code></pre>
						<p>1024 octets</p>

						<aside class="notes">
							... et la version soumise. 1024 octets tout pile.
						</aside>
					</section>

					<section>
						<small>... et si seulement j'avais découvert RegPack avant le dernier jour ...</small> 
					</section>
					<section>
						<h3>Version finale post-RegPack</h3>
						<pre style="width: 800px;"><code style="font: 'Courier New'; font-size: 0.8em; line-height: 90%;; white-space: -moz-pre-wrap;white-space: -moz-pre-wrap;word-wrap: break-word;">for(_='Math.__sin(^)+QQ"%",PeltaYOF?p:hNeightC?tB*(A]=@a.fillRect(=innerj%2?(v])+1g[/87)function(f){=Td[u||(forf.client=k-11-X*wheel--;),=225A6&lt;d[w	+o]-*F-FAl-1][u=[];_random()_cos(;onmouse0,0,W=c.widthWidth-18,H=c.hCHC-21W/dgX=R=r2;Y=.6;J=k=l=0@[T=o,5,Z=9,h=8];(D9&gt;l;){i=p*o-1;dh/;(++l]i)(j=p;jv==oAi/2|0Qj/2|0],w=i*p+j,l][w@	@(i%2?*2+	+p]+	/4:(v++o/2:+/2:vQhAY-	@6&gt;	]?6:	;o=i=pir/}g;setInterval(m=-Zw=-^Zz=Yx=^Yb=J;J%200*Tg=[],); (j=1e4;jtw,k=AR-2*ri=l,l=k/r+.5|0,p=h,h=k/r%1,F=h&gt;p,F==o*i+l]+(NQ(!Nv=F-X*z-3,Um,f=z*v+(I=m*U+w*t)*x,v=(v*x-z*I)/f*H+H,I=(w*U-m*t)/f*W+W,f&lt;p=v*2*W+I]p@f,p=],F-=t+(p-h*]-(1-h)**52,Style="hsla("+[p?25/p+b/p*4:7pB*3/p:FP(u=F-bB:5.2&lt;FB*t/5:6.05&lt;pB/p*2:6&lt;pB:1.6+*.8Qb*l*i/47*f/3QJ/13)*17P.6]+")",I,v,t=u/50+3-T,t)));++J},16)down=0}up}moveZ*X/W,Y=Y/H)}=onX+=f.dO|-f.DO}';g=/[-@-CN-Q^_]/.exec(_);)with(_.split(g))_=join(shift());eval(_)</code></pre>
						<p>1001 octets !!!</p>
					</section>
					
					<section>
						<img src="img/meme.gif" alt="Poker Face" /> 
					</section>

					<section>
						<h2>Classement</h2>

						<aside class="notes">
							Maintenant le résultat de manière générale ...
						</aside>
					</section>
					
					<section>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1555" >Strange crystals II</a>, de <a href="http://twitter.com/ehouais" >Philippe Deschaseaux</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1461" >Furbee</a>, de <a href="http://twitter.com/romancortes" >Roman Cortes</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1516" >3013 The 䕵 space-time fracture</a>, de <a href="http://twitter.com/p01" >Mathieu 'p01' Henri</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1558" >Synth Sphere</a>, de <a href="http://twitter.com/gleurop" >Noah Weninger</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1507" >Pointillism</a>, de <a href="http://twitter.com/b_aldream" >Benjamin Bill Planche</a> \o/</li>
								<li><a href="http://js1k.com/2013-spring/demo/1454" >3D City Tour</a>, de <a href="http://twitter.com/ehouais" >Jani Ylikangas</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1450" >Comanche</a>, de <a href="http://twitter.com/Siorki" >Siorki</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1376" >Color Factors</a>, de <a href="http://twitter.com/hugoware" >Pablo Caro</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1460" >Winter Wrap</a>, de <a href="http://twitter.com/veubeke" >Arne</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1431" >Psychedelic</a>, de <a href="http://twitter.com/ehouais" >Piotr Stosur</a></li>
							</ol>
							<small>cf <a href="https://gist.github.com/zz85/5522800">https://gist.github.com/zz85/5522800</a></small>
					</section>
					
					<section>
						<h3>Zoom sur le podium</h3>
							<ol>
								<li><a href="http://twitter.com/ehouais" >Philippe Deschaseaux</a> - 2012 : 4ème</li>
								<li><a href="http://twitter.com/romancortes" >Roman Cortes</a> - 2012 : 2ème; 2010 : 1er</li>
								<li><a href="http://twitter.com/p01" >Mathieu 'p01' Henri</a> - 2012 : 3ème; 2011 : 2ème ;...</li>
							</ol>
							<p>Des démos qui ont instantanément fait l'unanimité.</p>
					</section>
					
					<section>
						<p>... mais encore plus impressionnant ...</p>
					</section>
					
					<section>
						<p>Ils ont pris le temps de rendre hommage à la démo de l'autre!</p>
					</section>
					
					<section>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1451" >Furbee</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1461" style="margin-right:.5em;">Furbee, get out of that tunnel ASAP!</a></li>
							</ol>
							<ol>
								<li><a href="http://js1k.com/2013-spring/demo/1459" >Strange crystals</a></li>
								<li><a href="http://js1k.com/2013-spring/demo/1555" >Strange crystals II</a></li>
							</ol>
					</section>
					
					<section>
						<h3>Analyse des démos primées</h3>
						<ul>
							<li class="fragment">Très visuelles (3D, détails, ...)</li>
							<li class="fragment">Peu d'interactions</li>
							<li class="fragment">Peu d'API HTML5</li>
						</ul>

						<aside class="notes">
							Très visuelles, car ca reste le manière moyen d'accrocher un badaud lambda, d'attirer l'attention ... Et puis le canavs est mis à disposition, c'est presque une invitation implicite ...<br/><br/>
							
							Peu d'interactions, car ca prend de la place ! "onmousemove", "onclick", ... Des propriétés longues à écrire, des fonctions à coder pour chaque event, des comportements / objets event différents en fonction des browsers ... Décourageant.<br/>
							Et puis offrir du controle à l'utilisateur, c'est perdre du controle sur sa propre démo. Il vaut peut-être mieux être sûr que tout marche comme on le veut, que ca suive le scénario voulu.<br/>
							Pour vous donner une idée, plus de 10% de mon code - presque 150 octets - sont purement destinés aux controles ...<br/><br/>
							
							Peu d'API. Pareil, trop longs d'appeler de telles fonctions, et un comportement pas forcément homogène.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Bilan</h1>

						<aside class="notes">
							Il est donc finalement temps de faire un bilan de tout ça ...
						</aside>
					</section>
					
					<section>
						<h2>Demoscene</h2>

						<aside class="notes">
							Je commencerai par dire que js1k est une extension, voire même s'inscrit dans le Demoscene.<br/>
							Qu'est-ce que cela ?
						</aside>
					</section>
					
					<section>
						<blockquote cite="http://wikipedia.com">Sous-culture informatique ayant pour but la création artistique sous forme de programme, fondée sur les trois domaines que sont : la musique assistée par ordinateur, l’infographie et la programmation.</blockquote>

						<aside class="notes">
							Vous avez peut-être entendu parlé de ces programmeurs et leur concours ...<br/>Des démos tenant sur 4, 16, 64ko, codées sur des disquettes à l'époque, pour des PC mais aussi des Amiga, des Commodore 64, ... A l'époque le matériel informatique en soit était la source de la limitation et donc du challenge.<br/>
							Aujourd'hui, cette limitation se retrouve sur le Web, sand-boxé. Pouet.net, js1K, jsgames13k, ...<br/><br/>
							Le Web est devenu le nouveau far-west des programmeurs en quête de challenges.
						</aside>
					</section>
					
					<section>
						<p>Discipline pour <em>Hackers</em></p>

						<aside class="notes">
							Et donc ce genre de concours, selon moi, est organisés par et pour les Hackers.<br/>
							Dans le sens large du terme. Ceux qui recherchent l'astuce, le raccourcis, l'optimisation.
						</aside>
					</section>
					
					<section>
						<ul>
							<li>
								<p>Hacker le <strong>contenu</strong> du code</p>
								<code>Raccourcis langagiers, Mix d'algos, ...</code>
							</li>
							<li>
								<p>Hacker la <strong>forme</strong> du code</p>
								<code>Patterns, compressions, ...</code>
							</li>
						</ul>

						<aside class="notes">
							Pourquoi ? Parce que ce genre de challenge informatique requiert<br/>
							- De hacker le contenu du code. Le "faire beaucoup avec peu", avec toutes les astuces langagières ou mathématiques que l'on a vues.<br/>
							- Mais aussi de hacker la forme. De ne pas seulement voir ce que fait le code, mais comment est fait le code.<br/><br/>
							C'est un domaine un peu méta, mais tellement intéressant et remplis de challenges. Compression des données, développement / lutter contre de programmes malicieux, ...
						</aside>
					</section>
					
					<section>
						<blockquote cite="http://www.joshuakoo.com/">Its like a marathon where its better to have weeks of preparations, but everyone's a winner when they finish. &mdash; Joshua Koo</blockquote>

						<aside class="notes">
							Pour revenir sur le concours js1k même, je citerai Joshua Koo, un camarade participant, car il a trouvé la formulation juste.
						</aside>
					</section>
					
					<section>
						<ul>
							<li>Du fun et des larmes</li>
							<li>Une manière de (re)découvrir la programmation</li>
							<li>Des rencontres sympas</li>
						</ul>

						<aside class="notes">
							Ce que ce concours apporte, au dela du prix et de la visibilité ...<br/>
							- Un beau challenge à se donner<br/>
							- Une belle manière d'en apprendre plus sur son langage favori<br/>
							- Et enfin l'occasion d'échanger avec des gens partageant votre passion très souvent bien plus experts que vous ...
						</aside>
					</section>
					
					<section>
						<blockquote cite="https://twitter.com/salamondani">IMHO best compression scheme: imagination+time+math skills. &mdash; Philippe Deschaseaux (gagnant)</blockquote>

						<aside class="notes">
							Le mot de la fin, je le laisse au gagnant.<br/>Il s'agit de l'extrait d'un de ses tweets, retweeté par pas mal de compétiteurs car c'est l'avis partagé ...
						</aside>
					</section>
				</section>
					
				<section>
					<h1>Références</h1>
					<ul>
						<li><strong>140byt.es</strong>, <em><a href="https://github.com/jed/140bytes/wiki/Byte-saving-techniques">Byte-saving Techniques</a></em></li>
						<li><strong>Nikhil</strong>, <em><a href="http://blog.nikhilism.com/2012/04/demystifying-jscrush.html">Demystifying JSCrush</a></em></li>
						<li><strong>Roman Cortes</strong>, <em><a href="http://www.romancortes.com/blog/">Blog</a> (description de ses démos)</em></li>
						<li><strong>Philippe Deschaseaux</strong>, <em><a href="http://dev.ehouais.net/js1k/">Blog</a> (description de ses démos)</em></li>
						<li><strong>Joshua Koo</strong>, <em><a href="http://www.lab4games.net/zz85/blog/">Blog</a> (description de ses démos)</em></li>
						<li>...</li>
					</ul>
					<small> Toutes les descriptions de démos sont intéressantes à lire. Voir <a href="http://js1k.com">js1k.com</a></small>
				</section>
				
				<section>
					<h2>Merci pour votre attention !</h1>
					<small><a href="https://twitter.com/b_aldream">@b_aldream</a> | <a href="https://github.com/Aldream">git:Aldream</a> | <a href="http://aldream.net">aldream.net</a></small>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
