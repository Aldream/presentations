<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Survey on Random Number Generators | Benjamin (Bill) Planche</title>

		<meta name="description" content="Survey about Randomness and RNGs + Implementation of some famous algorithms (LFSR, NLFSR, Berlekamp-Massey). Personal work for the seminar The Art of Mathematical Computing (Universität Passau, Faculty of Computer Science, Summer 2014).">
		<meta name="author" content="Benjamin (Bill) Planche">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../css/reveal.js-2.6.1/reveal.min.css">
		<link rel="stylesheet" href="../css/reveal.js-2.6.1/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href=".../css/reveal.js-2.6.1/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="../css/reveal.js-2.6.1/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>
		<script src="../js/jquery-1.10.2.min.js"></script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>


		<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
		
<!-- -->
			<section>
				<h1>Random Number<br/>Generators</h1>
				<h4>The Art of Mathematical Computing</h4>
				<p>
					<small>by <a href="http://aldream.net">Benjamin (Bill) Planche</a><br/>
					feat. Philipp Jovanovic<br/>
					Slides at <a href="https://github.com/Aldream/presentations">github.com/Aldream/presentations</a></small>
				</p>

				<aside class="notes">
				<p>Benjamin (Bill) Planche - French - Last year</p>
				</aside>
			</section>
				
		
<!-- -->				
			<section>
				<section data-background="img/random-word-wall.jpg">
				
					<aside class="notes">
		<ul>
<li>Generation of random numbers = important operation for various computational tasks</li>
<li>Not all applications have the same requirements about randomness</li>
</ul>			
					</aside>
				</section>		
<!-- -->

				<section>
					<h1 id="structure">Structure</h1>
					<ol>
						<li>Randomness <small>- defs + pseudo-randomness</small></li>
						<li>RNGs & PRNGs <small>- defs + implementation</small></li>
						<li>Test Tools <small>- suites + implementation</small></li>
					</ol>

					<aside class="notes">
Overview of the most common requirements, solutions, test tools
					
					</aside>
				</section>
			</section>

		
<!-- -->
			<section>
				<section>
					<h1 id="randomness">Randomness</h1>

					<aside class="notes">
					
					</aside>
				</section>


				<section>
					<p><i>Lack of pattern, predictability or determinism in events.</i></p>

					<aside class="notes">
Lack of pattern, predictability or determinism in events.					
					</aside>
				</section>
				
				<section>
					<p><b>However.</b></p>
					<p class="fragment" ><i>Is it really random?</i></p>
					<p class="fragment" ><i>Or are we  simply ignorant of the underlying pattern?</i></p>

					<aside class="notes">
Is a structure really random, or are we  simply ignorant of a hidden underlying pattern?					
					</aside>
				</section>
		
<!-- -->					
				<section>
					<h2>Random Sequences</h2>
					<h4>Information Theory</h4>
					
					<div class="fragment">Basic definition
						<blockquote>Sequence of independent random variables</blockquote>
					</div>
					
					<div class="fragment" style="margin-top:1em;">Formal definition
						<blockquote>???</blockquote>
					</div>
					<aside class="notes">
<ul>
<li>Studied in Information Theory</li>
<li>Simple Def: Sequence of independent random variables</li>
<li>Formal/Mathematical Def -&gt; Subject of many debates and studies during the last century.</li>
</ul>					
					</aside>
					</ul>
				</section>
		
<!-- -->
				<section>
					<h2 id="definition-by-von-mises">Definition by Von Mises</h2>

					<aside class="notes">
1st attempt at defining algorithmic randomness by Richard Edler von Mises (1883-1953)					
					</aside>
				</section>

				<section>
						<small>Based on <b>Theory of Large Numbers</b></small>
						<p>An infinite sequence can be considered random if:</p>
						<ul>
							<li class="fragment"><b>It has the <i>Frequency Stability Property</i></b><ul>
								<li>$S \in \mathbb{A}^n$ with $\mathbb{A}$ alphabet of $m$ symbols</li>
								<li>$\forall a \in \mathbb{A}, \lim_{n \to \infty} |\{s, s \in S \land s = a\}| = \frac{1}{m}$</li>
							</ul></li>
							<li class="fragment"><b>Any sub-seq. selected by a <i>proper method</i> isn't biased too.</b> ex:<ul>
								<li>$ S = (1,0,1,0,1,0,1,0) $ not biased</li>
								<li>$f(X) \to (X^i | \forall i \leq |X| \land i \equiv 0 \pmod 2)$</li>
								<li> $\implies f(S) \to (1,1,1,1)$ biased</li>
							</ul></li>
						</ul>

					<aside class="notes">
<ul>
<li>Th of Large Numbers (AVG of results from a large nb of trials -&gt; Exp Val.)</li>
<li>
An infinite sequence of symbols can be considered random if :
<ul>
<li>Has Frequency stability property (the appearance frequencies of the symbols aren't biased /goes to the same expected value)</li>
<li>any sub-sequence selected by a "proper method" isn't biased too.<ul>
<li>Fundamental in this definition.</li>
<li>Ex: 10101010 is not biased, but we obtain the biased sub-sequence 0000 by selecting only the even positions.</li>
</ul>
</li>
</ul>
</li>
</ul>				
					</aside>
				</section>

				<section>
						<p><b>However.</b></p>
						
						<ul>
							<li class="fragment">How to mathematize this <i>proper method</i> of selection?</li>
							<li class="fragment">Yields an empty set (demo by Jean Ville in 1939)</li>
						</ul>

					<aside class="notes">
<p>But unsatisfying :</p>
<ul>
<li>How to mathematize what the "proper method of selection" was.</li>
<li>Demonstration by Jean Ville in 1939, proving that such a definition only yields an empty set.</li>
</ul>					
					</aside>
				</section>
		
<!-- -->
				<section>
					<h2 id="definition-by-martin-lof">Definition by Martin-Löf</h2>
					<aside class="notes">
Swedish statistician Per Martin-Löf. Def in 1966
					</aside>
				</section>

				<section>

					<blockquote>A Random Sequence has no "exceptional and effectively verifiable" property</blockquote>
						
					<ul>
						<li class="fragment">No properties verifiable by a recursive algorithm</li>
						<li class="fragment">Frequency / measure-theoretic</li>
						<li class="fragment">Quite satisfactory</li>
					</ul>

					<aside class="notes">
<ul>
<li>has no "exceptional and effectively verifiable" property</li>
<li>i.e. has no properties we can verify by a recursive algorithm</li>
<li>Most satisfactory frequency / measure-theoretic approach to randomness</li>
</ul>					
					</aside>
				</section>
		
<!-- -->
				<section>
					<h2 id="definition-by-levinchaitin">Definition by Levin/Chaitin</h2>

					<aside class="notes">
Leonid Anatolievich Levin (1948) and Gregory Chaitin (1947), in 1975				
					</aside>
				</section>

				<section>
					<h3 id="complexity-of-kolmogorov">Complexity of Kolmogorov</h3>
					<ul>
						<li>Important measure for Information Theory</li>
					</ul>
					
					<blockquote class="fragment">Length of the shortest program able to generate the sequence.</blockquote>

					<aside class="notes">
<ul>
<li>Ray Solomonoff (1926-2009) and Andre Nikolaevitch Kolmogorov (1903-1987), in the 60's</li>
<li>Important measure for Information Theory: complexity of Kolmogorov</li>
<li>Def: the length of the shortest program (independently of the machine) able to generate the evaluated sequence.</li>
</ul>				
					</aside>
				</section>
					
				<section>
					<h3 id="complixity-compressibility-def-of-randomness">Resulting Definition</h3>
					
					<blockquote>A finite string is random<br/>if it requires a program at least as long as itself to be computed</blockquote>
					<p> $\exists c \geq 0$, such as $H(S_0^n) \geq n - c$<br/>with $H$ complexity of Kolmogorov</p>
					<ul>
						<li class="fragment">"<i>Incomprehensible informational content</i>"</li>
						<li class="fragment">Complexity / Compressibility approach</li>
					</ul>
					
					<aside class="notes">
<ul>
<li>Levin/Chaitin</li>
<li>Def: random finite string = string which requires a program at least as long as itself to be computed</li>
<li>Another way to express it is: "a random sequence must have an incomprehensible informational content"
    -&gt; Impossible to make any sense of it, and thus to use a shorter sequence or program to describe it.</li>
<li>Approach is considered as a complexity / compressibility one.</li>
<li>Not really complexity of Kolmogorov, but of Chatain (condition: program must be auto-delimited</li>
</ul>				
					</aside>
				</section>
		
<!-- -->
				<section>
					<h2 id="definition-by-schnorr">Definition by Schnorr</h2>

					<aside class="notes">
Claus-Peter Schnorr [1943), in 1971					
					</aside>
				</section>

				<section>
					<blockquote>A random sequence must not be predictable.<br/>No effective strategy should lead to an infinite gain if we bet on its symbols.</blockquote>
					<ul>
						<li class="fragment">Predictability approach</li>
					</ul>

					<aside class="notes">
<ul>
<li>Predictability approach</li>
<li>"random sequence must not be predictable. No effective strategy should lead to an infinite gain if we bet on the symbols of the sequence"</li>
</ul>				
					</aside>
				</section>
		
<!-- -->

				<section>
					<h2>Statistical Randomness</h2>
					<blockquote class="fragment">A sequence is statistically random if it has no <b>recognizable</b> patterns.</blockquote>
					<ul class="fragment">
						<li>Less strict than previous definitions</li>
						<li>Doesn't imply objective unpredictability</li>		
					</ul>

					<aside class="notes">
Numeric sequence = statistically random if it contains no recognizable patterns or regularities.				
					</aside>
				</section>
				
				<section>
					<p>... leaves room to the concept of ...</p>

					<aside class="notes">
Less strict than prev. defs &amp;  doesn't imply objective unpredictability -&gt; leaves room to the concept of pseudo-randomness.				
					</aside>
				</section>
				<section>
					<h2 id="pseudorandomness">Pseudo-Randomness</h2>
					<h4>and Pseudo-Random Sequence</h4>
					<p class="fragment">Exhibits statistical randomness...</p>
					<p class="fragment">... though generated by a deterministic causal method.</p>

					<aside class="notes">
<ul>
<li>Pseudo-random sequence exhibits statistical randomness while being generated by an entirely deterministic causal method.</li>
<li>Largely used in computer science, to simulate random behaviors (truly random values can be too costly)</li>
<li>Algorithmically generated -&gt; can be used in a much simpler and frequent way.</li>
</ul>				
					</aside>
				</section>
			</section>
		
<!-- -->
			<section>
				<section>
					<h1 id="random-number-generators">Random Number Generators</h1>

					<aside class="notes">
A seen, mediums to generate random sequences have been used for a long time in various
domains, from politics to cryptology.<br/>
However, they are not all equal / have bias which can be a problem depending on the usages.
					</aside>
				</section>
				
				<section>
					<h2 id="definition">Definition</h2>

					<blockquote>Device which can produce a sequence of random numbers, i.e. a without deterministic properties and patterns.</blockquote>

					<aside class="notes">
RNG = device which can produce a sequence of random numbers, i.e. a without determinist properties and patterns.
					</aside>
				</section>

				<section>
					<h3>Methods of Generation</h3>
					<ul>
						<li class="fragment">Physical interactions</li>
						<li class="fragment">Computations (pseudo-randomness)</li>
						<li class="fragment">Mix of both</li>
					</ul>

					<aside class="notes">
<ul>
<li>Can use physical interactions, computations, or a mix of both, to achieve it.</li>
<li>Purely random sequences can't be described/generated by an algorithm (not recursive)</li>
<li>Computational methods can only create pseudorandom seq -&gt; PNRG</li>
</ul>		
					</aside>
				</section>
			</section>
			
<!-- -->			
				
			<section>

				<section>
					<h2 id="categories">Categories</h2>

					<aside class="notes">
					
					</aside>
				</section>
			</section>
				
				
			<section>

				<section>
					<h3 id="generators-based-on-physical-phenomena">Generators based on physical phenomena</h3>

					<aside class="notes">
					
					</aside>
				</section>


				<section>
					<h4 id="traditionnal-methods">Traditionnal Methods</h4>
					<p><small>Dice tossing, coin flipping, bird trajectories, ...</small></p>
					<ul>
						<li class="fragment">Often only random in appearances</li>
						<li class="fragment"><i>Cheating</i> by knowing the rules / initial state</li>
					</ul>

					<aside class="notes">
Coin flipping -&gt; dynamics rules applied to the trajectory<br/>
Seem random only because we can't simply measure the variables of the toss to solve the system.<br/>
<Meager hints about the initial conditions can still help deducing outcome<br/>
ex: the face on top before the coin is tossed may have more chances to be the resulting one				
					</aside>
				</section>
					
				<section>
					<h4 id="quantic-phenomena">Quantic Phenomena</h4>
					<p><small>Nuclear decay, Behavior of photons hitting a semi-transparent mirror, ...</small></p>
					<ul>
						<li class="fragment">Golden solutions</li>
						<li class="fragment">Globally too costly to be democratized</li>
					</ul>

					<aside class="notes">
<ul>
<li>Best phenomena to use as input for RNG = thus  possessing quantum mechanical physical randomness<ul>
<li>Found  in quantum mechanics at the atomic or sub-atomic level.</li>
<li>ex of methods impl.:<ul>
<li>measuring the nuclear decay with a Geiger counter</li>
<li>printing 0/1 when a photon is reflected/transmitted by a semi-transparent mirror</li>
</ul></li></ul>
Golden solutions, they are globally too costly to be democratized.			
					</aside>
				</section>
					
				<section>
					<h4 id="noisy-phenomena">Noisy Phenomena</h4>
					<p><small>Thermal signal from transistor, radio noise, Analog-to-digital conversion noise, ...</small></p>
					<ul>
						<li class="fragment">Easier to detect</li>
						<li class="fragment">Offer good results</li>
					</ul>

					<aside class="notes">
<ul>
<li>Easier to detect and offer good results.</li>
<li>Ex:<ul>
<li>amplifying the thermal signal from a transistor or from an atmospheric radio receiver</li>
<li>comparison of pictures from an agitated scene</li>
<li>noise from analog-to-digital converter, etc</li>
</ul>
</li>
</ul>					
					</aside>
				</section>
		
<!-- -->					
				<section>
					<h4 id="os-solutions">OS Implementations</h4>
					<ul>
					<li class="fragment">Based on the unpredictable IO + behavior of the users</li>
					<li class="fragment">Harvest <b>entropy</b>, Output random bytes</li>
					</ul>
					<aside class="notes">
					
					</aside>
				</section>
					
				<section>
					<h5>Unix Systems</h5>
					<ul>
						<li>$/dev/urandom$ & $/dev/random$</li>
						<li>Device files probing analog sources <small>(mouse, keyboard, disk accesses, etc.)</small></li>
					</ul>
					<div  class="fragment" style="margin-top:1.5em;">
					<h5>Windows Systems</h5>
					<ul>
						<li>$CryptGenRandom$</li>
						<li>Gather through system state <small>(CPU counters, env. var, threads IDs, etc.)</small></li>
					</ul>
					</div>

					<aside class="notes">
Device files probing analog sources (mouse, keyboard, disk acc, etc.)<br/>
Gather entropy though CPU counters, environment variables, threads IDs, etc.					
					</aside>
				</section>
					
				<section>
					<p>In both cases, entropy decreases during <i>inactivity</i></p>
					<p class="fragment"><b>... Shortages.</b></p>

					<aside class="notes">
					
entropy decreases during inactivity -&gt; shortages
					</aside>
				</section>
			</section>
				
		
<!-- -->				
			<section>
					
				<section>
					<h3 id="pseudo-random-number-generators">Pseudo-Random Number Generators</h3>

					<aside class="notes">
PRNG are generators based on algorithms.				
					</aside>
				</section>
					
				<section>
					<p>Ramdomness through Determinism...??</p>
					<img class="fragment" style="border:none; box-shadow:none; background:none;text-shadow:none;" src="http://i.imgur.com/Tx5Ai.png" alt="WTF?!">

					<aside class="notes">
Seem paradoxical to associate randomness with algorithms, by definition deterministic					
					</aside>
				</section>
				
				<section>
					<p>Pseudo-Random Sequences</p>
					
					<ul>
						<li class="fragment">Clever implementations $\rightarrow$ Long-enough period</li>
						<li class="fragment">Determinism $\rightarrow$ totally defined by init config<ul class="fragment">
							<li><i>State</i></li>
							<li><i>Seed</i></li></ul></li>
					</ul>

					<aside class="notes">
<ul>
<li>But some clever implementation -&gt; pseudo-random seq with periods long enough for their uses</li>
<li>Because PRNG deterministic, output sequences totally defined by init config -&gt; state</li>
<li>Key variable of state = seed (or random seed): number/vector which should be kept secret. </li>
</ul>				
					</aside>
				</section>
			</section>
				
		
<!-- -->				
			<section>
					
				<section>
					<h2 id="lfsr">LFSR</h2>
				</section>
				<section>
					<h4 id="lfsr">Linear Feedback Shift Register</h4>
					<ul>
						<li>Sequential shift register</li>
						<li>New bit = linear function of previous state</li>
						<li>Combinational logic</li>
						<li>$\mathfrak{F}$ mapping in vector space of binary $n$-tuples</li>
						<li>$f$ feedback function = boolean operation of $n$ variables</li>
					</ul>
					
					<p>$$\mathfrak{F}:\mathbb{F}_2^n \to \mathbb{F}_2^n$$
					$$\mathfrak{F}:(x_1, x_2, ..., x_n)\mapsto (x_2, x_3, ..., x_n, f((x_1, x_2, ..., x_n))$$</p>

					<aside class="notes">
<ul>
	<li>LFSR = sequential shift register whose input bit is a linear function of its previous state</li>
	<li>Combinational logic that causes it to pseudo-randomly cycle through a sequence of bin val</li>
	<li>Mapping Fn2 -&gt; Fn2 (vector space of all binary n-tuples)</li>
	<li>f = feedback function = Boolean operation of n variables</li>
</ul>				
					</aside>
				</section>
				
				<section>
					<ul>
						<li>$f$ $\equiv$ poly mod 2 in finite field arithmetic<ul>
							<li><i>Feedback polynomial</i></li></ul></li>
						<li class="fragment"><i>Taps</i> = bits of the register used in the linear operation</li>
						<li class="fragment">Conditions to maximal-length LFSR (period $2^n-1$):
						<ul>
							<li>Having an even number of taps</li>
							<li>Using a relatively-prime set of taps</li>
						</ul></li>
					</ul>

					<aside class="notes">
<ul>
	<li>The feedback function can be expressed in finite field arithmetic as a poly mod 2<ul>
		<li>Feedback polynomial or reciprocal characteristic polynomial</li>
	</ul>
	<li>Taps = bits of the register used in the linear operation (generally XOR)</li>
	</li>
	<li>To obtain a maximal-length LFSR (period 2^n-1), conditions must be met by the feedback func:<ul>
		<li>Having an even number of taps</li>
		<li>Using a relatively-prime set of taps ( no divisor other than 1 common to all taps )</li>
	</ul>
	</li>
</ul>						
					</aside>
				</section>
				
				<section>
					<h5>Example</h5>
					<p>$f(x) = x_{16} + x_{14} + x_{13} + x_{11} + 1$</p>
					<img alt="lfsr" src="img/lfsr.png" style="border:none; box-shadow:none; background:none;text-shadow:none;" />

					<aside class="notes">
					
					</aside>
				</section>
		
<!-- -->				
				<section>
					<h5>Implementation</h5>

					<aside class="notes">
					
					</aside>
				</section>
				
				<section>
					<h5>Python</h5>
					<pre><code style="font-size:.8em;">def createLFSRgenerator(taps, seed):
    """ Returns a LFSR generator, defined by the given sequence of taps and initial value.
        @param taps (Tuple[int]): Sequence of taps defining the register.
			ex: (1, 0, 0, 1) -> f(x) = x^4 + x^3 + 1
        @param seed (int):        Initial value given to the register
        @return                   LFSR Generator """
    def lfsrGen(): """ @yield Pseudo-Random value from the defined LFSR """
        deg = len(taps)              # Degree of the feedback polynomial
        period = math.pow(2,deg) - 1 # Max period of the LFSR
        value = seed                 # Initial value
        it = 0
        while (it < period): # Computing new value of most-significant bit:
            bit = 0
            for j in range(deg): # AND-operation between the current value and the taps-tuple
                if taps[j]:
                    bit ^= value >> j
            bit &= 1 # XOR-operation to get the new value of the bit
            # Final value in register by popping less-sign bit and appending the new most-sign one:
            value = (value >> 1) | (bit << (deg-1))
            it += 1
            yield value
    return lfsrGen</code></pre>

					<aside class="notes">
Quite Straightforward -> registers = sequence, bool op, closure+yield for generator
					</aside>
				</section>
				
				<section>
					<h5>Javascript</h5>
					<pre><code style="font-size:.8em;">function createLFSRGenerator(taps, seed) {
/** Returns a LFSR generator, defined by the given sequence of taps and initial value.
        @param taps (Tuple[int]): Sequence of taps defining the register.
			ex: (1, 0, 0, 1) -> f(x) = x^4 + x^3 + 1
        @param seed (int):        Initial value given to the register
        @return                   LFSR Generator */
    return function *lfsrGen() { /** @yield Pseudo-Random value from the defined LFSR */
        var deg = taps.length,              // Degree of the feedback polynomial
            period = Math.pow(2, deg) - 1,   // Max period of the LFSR
            value = seed;                     // Initial value
        for (var it = 0; it < period; it++) { // Computing new value of most-significant bit:
            var bit = 0;
            for (var j = 0; j < deg; j++) { // AND-operation between the current value and the taps-tuple
                if (taps[j])
                    bit ^= value >> j;
            }
            bit &= 1; // XOR-operation to get the new value of the bit
            // Final value in register by popping less-sign bit and appending the new most-sign one:
            yield (value = (value >> 1) | (bit << (deg - 1)));
        }
    }
}</code></pre>

					<aside class="notes">
Porting Python to JS here (ECMAScript 6 / JS 1.7) - Closure, yield & generator)<br/>
Only syntax sugar
					</aside>
				</section>
		
<!-- -->				
				<section>
					<h5>Let's play</h5>
					<input id="lfsr-poly" name="lfsr-poly" type="text" placeholder="Polynomial" style="width:10em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-right:1em;" />
					<input id="lfsr-deg" name="lfsr-deg" type="number" placeholder="Reg. Size" style="width:4em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin:1em;margin-left:-.5em;" />
					<input id="lfsr-seed" name="lfsr-seed" type="number" placeholder="Ini. Val." style="width:4em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-left:1em;" />
					<br/>
					<button id="lfsr-start" style="width:3em;height:1.7em;font-size:1em;text-align:center;border-radius:10px;margin-right:1em;">Start</button> <button id="lfsr-stop" style="width:3em;height:1.7em;font-size:1em;text-align:center;border-radius:10px;margin-left:1em;">Stop</button>
					<br/>
					<textarea id="lfsr-values" name="lfsr-values" style="width:11em;height:6em;font-size:1em;border-radius:10px;margin:1em;"></textarea>
					<textarea id="lfsr-bits" name="lfsr-bits" style="width:11em;height:6em;font-size:1em;border-radius:10px;margin:1em;"></textarea>
					
					<script>
var lfsrInterval = null;
$("#lfsr-start").click(function(){
	$('#lfsr-values').text('');
	$('#lfsr-bits').text('');
	if (lfsrInterval) { clearInterval(lfsrInterval); }
	var taps = binPolyStringToArray($('#lfsr-poly').val(), parseInt($('#lfsr-deg').val()));
	var seed = parseInt($('#lfsr-seed').val());
	taps.pop();
	var lfsr = createLFSRGenerator(taps, seed)();
	
	var lfsrFunc = function() {
		var value = lfsr.next().value;
		bit = getBitFromInt(value,0);
		$('#lfsr-values').append(value + ', ');
		$('#lfsr-bits').append(bit + ', ');
	};
	lfsrInterval = setInterval(lfsrFunc, 1500);
});
$("#lfsr-stop").click(function(){
	if (lfsrInterval) { clearInterval(lfsrInterval); }
});
					</script>

					<aside class="notes">
x^4 + x^1 + 1<br/>
x^16 + x^14 + x^13 + x^11 + 1<br/>
The 'one' in the polynomial does not correspond to a tap – it corresponds to the input to the first bit 	
					</aside>
				</section>
			</section>
				
		
<!-- -->				
			<section>
					
					
				<section>
					<h2 id="lfsr">NLFSR</h2>
				</section>
				<section>
					<h4 id="lfsr">Non-Linear Feedback Shift Register</h4>
					<p class="fragment">Same theory as for LFSRs</p>

					<aside class="notes">
Same theory as for LFSRs				
					</aside>
				</section>
				
				<section>
					<p>Only one difference</p>
					<p class="fragment"><b>The feedback function $f$ is non-linear</b></p>
					<p class="fragment">ex: $f(x) = x^4 + x^1 \cdot x^2 + 1$<br/>
						<img alt="nlfsr" src="img/nlfsr.png" style="border:none; box-shadow:none; background:none;text-shadow:none;" />
					</p>
					
					<ul class="fragment">
						<li>Makes NLFSRs harder to predict than LFSRs</li>
						<li>Makes it harder to ensure a max period of $2^n-1$ bits.</li>
					</ul>

					<aside class="notes">
<ul>
<li>
Only difference: the feedback function f is non-linear</li>
<li>It makes NLFSRs harder to predict than LFSRs</li>
<li>But also imposes extensive carefulness to ensure a maximal period of 2^n-1 bits.</li>
<li>Lot of papers simply defining those conditions or listing the right config.</li>
</ul>					
					</aside>
				</section>
			
<!-- -->			
				<section>
					<h5>Implementation</h5>
				</section>
				
				<section>
					<h5>Python</h5>
					<pre><code style="font-size:.8em;">def createNLFSRgenerator(taps, seed):
    """ Returns a NLFSR generator, defined by the given combination of taps and initial value.
        @param taps (Tuple[Array[int]]): Sequence of combination of taps defining the non-linear register.
            ex: ([0,0],[],[2],[1,2]) -> f(x) = x^4*x^4 + x^2  + x^1*x^2 + 1 (poor choice)
        @param seed (int):              Initial value given to the register
        @return                         NLFSR Generator """
    def nlfsrGen(): """ @yield Pseudo-Random value generated by a pre-defined NLFSR """
        deg = len(taps)              # Degree of the feedback polynomial
        period = math.pow(2,deg) - 1 # Max Period of the NLFSR (read Warning above)
        value = seed                 # Initial value
        it = 0
        while (it < period): # Computing the new value of the most-significant bit:
            bit = 0
			for tap in taps:
                # Computing the binary multiplication x^K_0 * x^K_1 * ... * x^K_n with [K_0, K_1, ..., K_n] the j-th taps array
                if len(tap):
                    element = 1
                    for k in tap:
                        if not (value >> k & 1):
                            element = 0 # Binary multiplication of terms returns 1 iif none of the terms is null.
                            break       # So if we encounter a null bit, we simply return 0, else 1.
                else:
                    element = 0
                bit ^= element # Binary addition of the multiplication results
            bit &= 1
            # Getting the final value in the register by popping the less-significant bit and appending the new most-significant one:
            value = (value >> 1) | (bit << (deg-1))
            it += 1
            yield value
    return nlfsrGen</code></pre>
					<aside class="notes">
Almost same as LFSR<br/>
Just one more loop to do the multiplication of the non-linear syndromes.<br/>
Small trick for binary multiplication.				
					</aside>
				</section>
				
				<section>
					<h5>Javascript</h5>
					<pre><code style="font-size:.8em;">function createNLFSRgenerator(taps, seed) {
    /** Returns a NLFSR generator, defined by the given combination of taps and initial value.
        @param taps (Tuple[Array[int]]): Sequence of combination of taps defining the non-linear register.
            ex: ([0,0],[],[2],[1,2]) -> f(x) = x^4*x^4 + x^2  + x^1*x^2 + 1 (poor choice)
        @param seed (int):              Initial value given to the register
        @return                         NLFSR Generator */
    return function *nlfsrGen() { /** @yield Pseudo-Random value generated by a pre-defined NLFSR */
        var deg = taps.length,              // Degree of the feedback polynomial
            period = Math.pow(2,deg) - 1, // Max Period of the NLFSR (read Warning above)
            value = seed,                 // Initial value
            it = 0
        while (it < period) {             // Computing the new value of the most-significant bit:
            var    bit = 0
			for (var j = 0; j < taps.length; j++) {
				var	element = 1;
                if (taps[j].length) { // Computing the binary multiplication x^K_0 * x^K_1 * ... * x^K_n with [K_0, K_1, ..., K_n] the j-th taps array
                    for (var k = 0; k < taps[j].length; k++) {
                        if (!(value >> taps[j][k] & 1)) {
                            element = 0;  // Binary multiplication of terms returns 1 iif none of the terms is null.
                            break;        // So if we encounter a null bit, we simply return 0, else 1.
                         }
                    }
                } else { element = 0; }
                bit ^= element;          // Binary addition of the multiplication results:
            }
            bit &= 1;
            // Getting the final value in the register by popping the less-significant bit and appending the new most-significant one:
            it += 1;
            yield (value = (value >> 1) | (bit << (deg-1)));
        }
    }
}</code></pre>
					<aside class="notes">
Same o' same					
					</aside>
				</section>
		
<!-- -->				
				<section>
					<h5>Let's play</h5>
					<input id="nlfsr-poly" name="nlfsr-poly" type="text" placeholder="Polynomial" style="width:10em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-right:1em;" />
					<input id="nlfsr-deg" name="nlfsr-deg" type="number" placeholder="Reg. Size" style="width:4em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin:1em;margin-left:-.5em;" />
					<input id="nlfsr-seed" name="nlfsr-seed" type="number" placeholder="Ini. Val." style="width:4em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-left:1em;" />
					<br/>
					<button id="nlfsr-start" style="width:3em;height:1.7em;font-size:1em;text-align:center;border-radius:10px;margin-right:1em;">Start</button> <button id="nlfsr-stop" style="width:3em;height:1.7em;font-size:1em;text-align:center;border-radius:10px;margin-left:1em;">Stop</button>
					<br/>
					<textarea id="nlfsr-values" name="nlfsr-values" style="width:11em;height:6em;font-size:1em;border-radius:10px;margin:1em;"></textarea>
					<textarea id="nlfsr-bits" name="nlfsr-bits" style="width:11em;height:6em;font-size:1em;border-radius:10px;margin:1em;"></textarea>
					
					<script>
var nlfsrInterval = null;
$("#nlfsr-start").click(function(){
	$('#nlfsr-values').text('');
	$('#nlfsr-bits').text('');
	if (nlfsrInterval) { clearInterval(nlfsrInterval); }
	var deg = parseInt($('#nlfsr-deg').val());
	var taps = nlBinPolyStringToArray($('#nlfsr-poly').val(), deg);
	var seed = parseInt($('#nlfsr-seed').val());
	taps.pop();
	var nlfsr = createNLFSRgenerator(taps, deg, seed)();
	
	var nlfsrFunc = function() {
		var value = nlfsr.next().value;
		bit = getBitFromInt(value,0);
		$('#nlfsr-values').append(value + ', ');
		$('#nlfsr-bits').append(bit + ', ');
	};
	nlfsrInterval = setInterval(nlfsrFunc, 1500);
});
$("#nlfsr-stop").click(function(){
	if (nlfsrInterval) { clearInterval(nlfsrInterval); }
});
					</script>

					<aside class="notes">
Check algo by runing same LFSR x^4 + x + 1<br/>
Bad config: x^4*x^4*x^3 + x^1*x^2 + x^1*x^3 + 1<br/>
Better config: x^4 + x^3 + x^2  + x^1*x^2 + 1	
					</aside>
				</section>
			</section>
				
		
<!-- -->				
			<section>

				<section>
					<h2 id="applications-and-uses">Applications and Uses</h2>

					<aside class="notes">
					
					</aside>
				</section>

				<section>
					<p>Applications in every area<br/>where unpredictable behavior is desirable/required</p>
					<small>cryptographic systems, gambling applications, statistical sampling, simulation, ...</small>

					<aside class="notes">
From cryptographic systems to gambling applications, statistical sampling, simulation, ...					
					</aside>
				</section>
				
				<section>
					<p>Various applications $ \rightarrow $ Various requirements</p>
					<ul class="fragment">
						<li>Crypto-secure RNGs for security applications</li>
						<li>Outputs uniqueness for shuffling methods</li>
						<li>...</li>
					</ul>

					<aside class="notes">
<ul>
<li>Various properties can be required from the generators:<ul>
<li>Security application will need a cryptographically-secure RNG</li>
<li>Shuffling method will require uniqueness of the returned values</li>
</ul>				
					</aside>
				</section>
				
				<section>
					<ul>
						<li>RNGs $ \rightarrow $ ~ safer but less abundant</li>
						<li>PRNGs $ \rightarrow $ ~ weaker but lighter</li>
						<li class="fragment">RNGs seeded by a strong PRNG</li>
					</ul>
					<p>
					<img class="fragment" src="https://sslimgs.xkcd.com/comics/random_number.png" title="xkcd - Random Number" />
					</p>
					<aside class="notes">
<ul>
<li>Some require qualities mostly found in physical RNGs</li>
<li>Others are satisfied with weaker forms of randomness (faster and lighter)</li>
<li>Common to use a RNG to seed a strong PRNG, to increase the entropy</li>
</ul>					
					</aside>
				</section>
			</section>
		
<!-- -->
			<section>
				<section>
					<h1 id="testing-randomness">Testing Randomness</h1>

					<aside class="notes">			
					</aside>
				</section>

				<section>
					<p>The definition of randomness is complex and application-dependent...</p>

					<aside class="notes">
Def of randomness is complex and app-dependent, so are the tests designed for RNGs.	
					</aside>
				</section>
				
				<section>
					<p>... so are the tests designed for RNGs.</p>

					<aside class="notes">
					
					</aside>
				</section>

				<section>
					<h2 id="about-the-difficulty-to-test-randomness">About the Difficulty to Test Randomness</h2>

					<aside class="notes">
					
					</aside>
				</section>

				<section>
					<h3>Reasons</h3>
					<ul>
						<li class="fragment">Def. depending on the field $ \rightarrow $ <i>Which one to test?</i></li>
						<li class="fragment">Large number of possibilities $ \rightarrow $ Impossible to fully cover</li>
					</ul>

					<aside class="notes">
<ul><li>"Random sequence" -&gt; various meanings depending on the field, so difficult to test</li>
<li>Like for Crypto, large number of possibilities -&gt; impossible to fully cover<ul>
<li>ex: checking if a sequence has indeed no shorter construction is impossible without
checking every construction</li>
</ul>				
					</aside>
				</section>
		
<!-- -->				
				<section>
					<h3>Solutions</h3>
					<ul>
						<li class="fragment">Statistical tests or complexity evaluations</li>
						<li class="fragment">Battery of tests to identify statistical bias</li>
						<li class="fragment">Checking hypothesis of <i>perfect behavior</i></li>
					</ul>

					<aside class="notes">
Solutions: statistical tests or complexity evaluations (Kolmogorov)<br/>
"Perfect Behavior" : values of the sequences "imitate independent random var from the uniform distribution"		
					</aside>
				</section>
				
				<section>
					<h3>Limitations</h3>
					<ul>
						<li class="fragment">Different tests detect different problems</li>
						<li class="fragment">Impossible to fully cover $ \rightarrow $ no universal battery of tests</li>
						<li class="fragment">Good RNGs $ \approx $ pass complicated or numerous tests</li>
					</ul>

					<aside class="notes">
<ul>
<li>Different tests will thus detect different problems, various statistical behaviors</li>
<li>Impossible to full cover -&gt; no universal battery of tests</li>
<li>So good RNGs are then those which pass complicated or numerous tests</li>
</ul>				
					</aside>
				</section>
		
<!-- -->
				<section>
					<h2 id="common-tests">Common Tests</h2>

					<aside class="notes">
					
					</aside>
				</section>

				<section>
					<h3 id="diehard-tests">DIEHARD Tests</h3>
					<ul>
						<li class="fragment">Developed by George Marsaglia, in 1995</li>
						<li class="fragment">15 tests run over a large file containing the sequence</li>
					</ul>
					<blockquote class="fragment">birthday spacings, overlapping permutations, ranks of 31x31 and 32x32 matrices, ranks of 6x8 matrices, monkey tests, count the 1's, parking lot, minimum distance, random spheres, squeeze, overlapping sums, runs, and craps</blockquote>

					<aside class="notes">
<ul style="font-size:.9em;"><li>15 tests, which are run over a large file containing the sequence, provided by the user</li>
<li>Birthday spacings: Choose random points on a large interval. The spacings between the points should be asymptotically exponentially distributed.[clarification needed] The name is based on the birthday paradox.</li>
<li>Overlapping permutations: Analyze sequences of five consecutive random numbers. The 120 possible orderings should occur with statistically equal probability.</li>
<li>Ranks of matrices: Select some number of bits from some number of random numbers to form a matrix over {0,1}, then determine the rank of the matrix. Count the ranks.</li>
<li>Monkey tests: Treat sequences of some number of bits as "words". Count the overlapping words in a stream. The number of "words" that don't appear should follow a known distribution. The name is based on the infinite monkey theorem.</li>
<li>Count the 1s: Count the 1 bits in each of either successive or chosen bytes. Convert the counts to "letters", and count the occurrences of five-letter "words".</li>
<li>Parking lot test: Randomly place unit circles in a 100 x 100 square. If the circle overlaps an existing one, try again. After 12,000 tries, the number of successfully "parked" circles should follow a certain normal distribution.</li>
<li>Minimum distance test: Randomly place 8,000 points in a 10,000 x 10,000 square, then find the minimum distance between the pairs. The square of this distance should be exponentially distributed with a certain mean.</li>
<li>Random spheres test: Randomly choose 4,000 points in a cube of edge 1,000. Center a sphere on each point, whose radius is the minimum distance to another point. The smallest sphere's volume should be exponentially distributed with a certain mean.</li>
<li>The squeeze test: Multiply 231 by random floats on (0,1) until you reach 1. Repeat this 100,000 times. The number of floats needed to reach 1 should follow a certain distribution.</li>
<li>Overlapping sums test: Generate a long sequence of random floats on (0,1). Add sequences of 100 consecutive floats. The sums should be normally distributed with characteristic mean and sigma.</li>
<li>Runs test: Generate a long sequence of random floats on (0,1). Count ascending and descending runs. The counts should follow a certain distribution.</li>
<li>The craps test: Play 200,000 games of craps, counting the wins and the number of throws per game. Each count should follow a certain distribution.</li>
</ul>		
					</aside>
				</section>
					
				<section>
					<h3 id="testu01-suite">TestU01 Suite</h3>
					<ul>
						<li class="fragment">Software library, initiated in 1985</li>
						<li class="fragment">Collection of utilities in ANSI C</li>
						<li class="fragment">Classical stat tests + others from literature + original ones</li>
						<li class="fragment">Tools to implement specific stat tests.</li>
					</ul>

					<aside class="notes">
					
					</aside>
				</section>
			</section>
				
		
<!-- -->				
			<section>
					
				<section>
					<h3 id="berlekamp-massey-algorithm">Berlekamp-Massey Algorithm</h3>

					<aside class="notes">
					
					</aside>
				</section>
					
				<section>
					<h4 id="definition_1">Definition</h4>
					
					<ul>
						<li class="fragment">Find the min poly of linearly recurrent sequences in $\mathbb{F}_n$</li>
						<li class="fragment">Find min degree $L$ and annihilator $F(x)$ of the seq $S$</li>
					</ul>

					<aside class="notes">
<ul>
<li>Invented by Elwyn Berlekamp in 1967 for decoding BCH codes</li>
<li>Adapted + simplified by James Massey</li>
<li>Algo, not really a test. Used to find in a field Fk the min poly of linearly recurrent sequences</li>
<li>Determine minimal degree L + annihilator (or inverse feedback) polynomial F(x) of the given sequence S</li>
</ul>						
					</aside>
				</section>
		
<!-- -->					
				<section>
					<h4 id="algorithm">Algorithm</h4>
					
					<ul>
						<li class="fragment">$F(x)$ uniquely determined by the first $2L$ elements of $S$</li>
						<li class="fragment">Requires to solve a set of $L$ linear equations</li>
					</ul>

					<aside class="notes">
<ul>
<li>Finding this minimal polynomial requires to solve a set of L linear equations</li>
<li>F(x) being indeed uniquely determined by the 1st 2L elements of S</li>
</ul>					
					</aside>
				</section>
					
				<section>
					<h4 id="algorithm">Algorithm</h4>
					
					<ul>
						<li>At each iteration $l$:<ul>
							<li>Evaluate the <i>discrepancy</i></li>
							<li>If null:<ul>
								<li>$F(x)$ and $L$ still correct</li>
								<li>Go to next iteration</li>
							</ul></li>
							<li>Else:<ul>
								<li>$F(x)$ should be concordantly adjusted</li>
								<li>Shift & Scale syndromes added since last update</li>
							</ul></li>
							<li>If $l > 2L$:<ul>
								<li>Update $L$ to keep track of progression</li>
							</ul></li>
						</ul></li>
					</ul>

					<aside class="notes">
<ul>
<li>At each iteration, it evaluates the discrepancy (difference between things that should be the same)</li>
<li>If beta = 0, F(x) and L are still currently correct -&gt; go next iteration</li>
<li>If beta != 0, F(x) should be concordantly adjusted, by shifting + scaling the syndromes added since the last update of L </li>
<li>In order to keep track of the number of errors and current degree of the
polynomial, L should be updated, otherwise the discrepancies will reach 0 before l grows bigger than 2L.</li>
</ul>					
					</aside>
				</section>
		
<!-- -->					
				<section>
					<h4 id="implementation">Implementation</h4>

					<aside class="notes">
					
					</aside>
				</section>
				
				<section>
					<h5>Python</h5>
					<pre><code style="font-size:.8em;">def BerlekampMasseyAlgorithm(sequence):
    """ Applies the Berlekamp-Massey Algorithm to the given sequence of bits;
        Returns the smallest annihilating polynomial F, ie. the smallest inverse
        feedback polynomial corresponding to the generating LFSR.( F(sequence) = 0 )
        @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
        @returns Array defining the computed inverse feedback polynomial
            ex: [1, 0, 0, 1, 1] represents the inverse polynomial x^4 + x^3 + 1,
                and thus the feedback polynomial x^4 + x + 1 (taps = (1, 0, 0, 1)) """
    
    def discrepancy(sequence, poly, i, L):
        """ Returns the discrepancy.
            @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
            @param poly (Array[int]):                   Current version of the inverse polynomial
            @param i (int):                             Current position in the sequence
            @param L (int):                             Current number of assumed errors
            @return                                     Binary value of the discrepancy """
        return sum([sequence[i-j]&poly[j] for j in range(0,L+1)])%2 # = s[i]*p[i] + s[i-1]*p[1] + ... + s[i-L]*p[L]
    
    def addPoly(poly1, poly2, length):
        """ Computes the addition of two F2 polynomials.
            @param poly1 (Array[int]): Array representing the 1st polynomial
            @param poly2 (Array[int]): Array representing the 2nd polynomial
            @param length (int):       Length to be covered by the addition (trusting user to avoid testing)
            @returns                   Resulting Binary Array  """
        return [poly1[j]^poly2[j] for j in range(0, length)]

    # Initializing: 
    N = len(sequence)
    F, f = [0]*N, [0]*N # Polynomials, with F being the one returned at the end (inverse feedback polynomial)
    F[0] = f[0] = 1
    L = 0               # Current number of assumed errors
    delta = 1           # Number of iterations since last update of L
    for l in range(N):  # Computing F and L:
        beta = discrepancy(sequence, F, l, L)
        if beta != 0:   # Adjusting F for this term:
            g = F.copy()
            F = addPoly(F, [0]*delta + f, N)
            if 2 * L <= l:    # If it is not the case, we must update L (and thus re-initalize delta), and also f:
                L = l + 1 - L # number of available syndromes used to calculate discrepancies
                delta = 1
                f = g # f get the previous value of F
            else: delta += 1
        else: delta += 1
    return F[:L+1] # output the polynomial</code></pre>

					<aside class="notes">
Trickier.<br/>
Poly represented by list -> Using list operations (shift, concatenation, ...)<br/>
List comprehension				
					</aside>
				</section>
				
				<section>
					<h5>Javascript</h5>
					<pre><code style="font-size:.8em;">function BerlekampMasseyAlgorithm(sequence) {
    /** Applies the Berlekamp-Massey Algorithm to the given sequence of bits;
        Returns the smallest annihilating polynomial F, ie. the smallest inverse
        feedback polynomial corresponding to the generating LFSR.( F(sequence) = 0 )
        @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
        @returns Array defining the computed inverse feedback polynomial
            ex: [1, 0, 0, 1, 1] represents the inverse polynomial x^4 + x^3 + 1,
                and thus the feedback polynomial x^4 + x + 1 (taps = (1, 0, 0, 1)) */
    
    function discrepancy(sequence, poly, i, L) {
        /** Returns the discrepancy.
            @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
            @param poly (Array[int]):                   Current version of the inverse polynomial
            @param i (int):                             Current position in the sequence
            @param L (int):                             Current number of assumed errors
            @return                                     Binary value of the discrepancy */
		var disc = 0;
		for (var j = 0; j < L+1; j++) disc += (sequence[i-j] & poly[j]) // disc = s[i]*p[i] + s[i-1]*p[1] + ... + s[i-L]*p[L]
		return disc%2;
	}
    
	function addPoly(poly1, poly2, length) {
        /** Computes the addition of two F2 polynomials.
            @param poly1 (Array[int]): Array representing the 1st polynomial
            @param poly2 (Array[int]): Array representing the 2nd polynomial
            @param length (int):       Length to be covered by the addition (trusting user to avoid testing)
            @returns                   Resulting Binary Array  */
		var poly = [];
		for (var j = 0; j < length; j++) poly.push(poly1[j] ^ poly2[j]);
		return poly;
	}

    // Initializing: 
    var N = sequence.length;
    var F = [], f = [] 		// Polynomials, with F being the one returned at the end (inverse feedback polynomial)
	for (var i = 0; i < N; i++) { F.push(0); f.push(0); }
    F[0] = f[0] = 1
    var L = 0               // Current number of assumed errors
    var delta = 1           // Number of iterations since last update of L
    for (var l = 0; l < N; l++) { // Computing F and L:
        var beta = discrepancy(sequence, F, l, L);
        if (beta != 0) { // Adjusting F for this term:
            var g = F.slice(0);
			var fShifted = f.slice(0); for (var k = 0; k < delta; k++) { fShifted.unshift(0); }
            F = addPoly(F, fShifted, N);
            if (2 * L <= l) {
                L = l + 1 - L; // number of available syndromes used to calculate discrepancies
                delta = 1;
                f = g; // f get the previous value of F
            } else delta += 1;
		} else delta += 1;
	}
	for (var k = L+1; k < N; k++) { F.pop(); }
    return F; // output the polynomial
}</code></pre>

					<aside class="notes">
Porting npt straightforward.<br/>
Not the same operation in JS on Array (no concatenate, no comprehension)<br/>
Heavier syntax.		
					</aside>
				</section>
			
<!-- -->			
				<section>
					<h5>Let's play</h5>
					<textarea id="berle-seq" name="berle-seq" style="width:25em;height:4em;font-size:1em;border-radius:10px;margin:1em;"></textarea><br/>
					<button id="berle-start" style="width:3em;height:1.7em;font-size:1em;text-align:center;border-radius:10px;margin-right:1em;">Start</button><br/>
					<input id="berle-poly" name="berle-poly" type="text" placeholder="Polynomial" style="width:16em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-right:.5em;" />
					<input id="berle-deg" name="berle-deg" type="number" placeholder="Reg. Size" style="width:4em;height:2em;font-size:1.2em;text-align:center;border-radius:10px;margin-top:1em;margin-bottom:1em;" />
					<p>Iteration <strong id="berle-it">0</strong><br/>$\beta$ = <strong id="berle-disc">0</strong><br/>(<em id="berle-status">stopped</em>)</p>
					<script>
					
function *SequentialBerlekampMasseyAlgorithm(sequence) {
    /*
        Applies the Berlekamp-Massey Algorithm to the given sequence of bits;
        Returns the smallest annihilating polynomial F, ie. the smallest inverse
        feedback polynomial corresponding to the generating LFSR.( F(sequence) = 0 )
        @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
        @returns Array defining the computed inverse feedback polynomial
            ex: [1, 0, 0, 1, 1] represents the inverse polynomial x^4 + x^3 + 1,
                and thus the feedback polynomial x^4 + x + 1 (taps = (1, 0, 0, 1))
    */
    
    function discrepancy(sequence, poly, i, L) {
        /*
            Returns the discrepancy.
            @param sequence (Array[int] or Tuple[int]): Sequence of bits to analyze
            @param poly (Array[int]):                   Current version of the inverse polynomial
            @param i (int):                             Current position in the sequence
            @param L (int):                             Current number of assumed errors
            @return                                     Binary value of the discrepancy
        */
		var disc = 0;
		for (var j = 0; j < L+1; j++) {
			disc += (sequence[i-j] & poly[j]) // disc = s[i]*p[i] + s[i-1]*p[1] + ... + s[i-L]*p[L]
		}
		return disc%2;
	}
    
	function addPoly(poly1, poly2, length) {
        /*
            Computes the addition of two F2 polynomials.
            @param poly1 (Array[int]): Array representing the 1st polynomial
            @param poly2 (Array[int]): Array representing the 2nd polynomial
            @param length (int):       Length to be covered by the addition (trusting user to avoid testing)
            @returns                   Resulting Binary Array 
        */
		var poly = [];
		for (var j = 0; j < length; j++) {
			poly.push(poly1[j] ^ poly2[j]);
		}
		return poly;
	}

    // Notes: the variables names are based on those in the pseudo-code found in
    //        JOUX, Antoine. Algorithmic cryptanalysis. CRC Press, 2009.,
    //        Algorithm 2.14, page 56
    
    // Initializing: 
    var N = sequence.length;

    var F = [], f = [] // Polynomials, with F being the one returned at the end (inverse feedback polynomial)
	for (var i = 0; i < N; i++) { F.push(0); f.push(0); }
    F[0] = f[0] = 1
    var L = 0               // Current number of assumed errors
    var delta = 1           // Number of iterations since last update of L

    // Computing F and L:
    for (var l = 0; l < N; l++) {
        var beta = discrepancy(sequence, F, l, L);
        // If the discrepancy is null, we can assume that F and L are currently correct and can continue with the next term.
        // Else, we must adjust F:
        if (beta != 0) {
            // Adjusting F for this term:
            var g = F.slice(0);
			var fShifted = f.slice(0);
			for (var k = 0; k < delta; k++) { fShifted.unshift(0); }
            F = addPoly(F, fShifted, N);
            
            // L represents the number of error, so the discrepancies will reach 0 before l grows bigger than 2*L
            // If it is not the case, we must update L (and thus re-initalize delta), and also f:
            if (2 * L <= l) {
                L = l + 1 - L; // number of available syndromes used to calculate discrepancies
                delta = 1;
                f = g; // f get the previous value of F
            } else {
                delta += 1;
			}
		} else {
            delta += 1;
		}
		
		var g = F.slice(0);
		for (var k = L+1; k < N; k++) { g.pop(); }
		yield {it:l, poly:g, disc: beta, l:L};
	}

	for (var k = L+1; k < N; k++) { F.pop(); }
    // output the polynomial
    yield {it:l, poly:F, disc: 0, l:L};
}


var berleInterval = null;
$("#berle-start").click(function(){
	$('#berle-poly').text('');
	$('#berle-deg').text('');
	$('#berle-it').text('0');
	$('#berle-disc').text('0');
	$('#berle-status').text('running');
	if (berleInterval) { clearInterval(berleInterval); }
	var seq = $('#berle-seq').val().replace(/\s/g,'').split(',');
	var berle = SequentialBerlekampMasseyAlgorithm(seq);
	
	var berleFunc = function() {
		var value = berle.next().value;
		if (value) {
			$('#berle-poly').val(polyToString(value.poly.reverse()));
			$('#berle-deg').val(value.l);
			$('#berle-it').text(value.it);
			$('#berle-disc').text(value.disc);
		} else {
			$('#berle-status').text('over!');
			clearInterval(berleInterval);
		}
	};
	berleInterval = setInterval(berleFunc, 500);
});
$("#berle-stop").click(function(){
	if (berleInterval) { clearInterval(berleInterval); }
});
					</script>

					<aside class="notes">
					
					</aside>
				</section>
			</section>
		
<!-- -->
			<section>
				<section>
					<h1 id="conclusion">Conclusion</h1>

					<aside class="notes">
					
					</aside>
				</section>
				
				<section>
					<p>Overview of a large topic</p>
					<ul>
						<li class="fragment">Various characteristics / Various Uses</li>
						<li class="fragment">Choose wisely!</li>
						<li class="fragment">Don't implement your own RNG!<ul>
							<li class="fragment">... especially for crypto!</li>
							<li class="fragment">... but if you try, test test test!</li></ul></li>
					</ul>

					<aside class="notes">
								
					</aside>
				</section>
			</section>

			<section>
				<h1>References</h1>
				<small style="font-size:.5em;">Presentation based on a personal survey: <a href="https://github.com/Aldream/random-number-generator" title="Github Repo">https://github.com/Aldream/random-number-generator</a></small>
				<ol style="font-size:.5em; line-height:70%;">
					<li>Downey, R.: Some recent progress in algorithmic randomness. In Mathematical Foundations of Computer Science 2004. Springer Berlin Heidelberg (2004)</li>
					<li>Wikipedia: Random Number Generation (2014)</li>
					<li>Aumasson, J.P.: Crypto for Developers - Part 2, Randomness. AppSec Forum Switzerland 2013 (2013)</li>
					<li>Raymond, S., Andrew, S., Patrick, C., Jason, M.: Linear Feedback Shift Register (2001)</li>
					<li>Joux, A.: Algorithmic cryptanalysis. CRC Press (2009)</li>
					<li>Szmidt, J.: The Search and Construction of Nonlinear Feedback Shift Registers. Military Communication Institute, Zegrze, Poland (2013)</li>
					<li>Wikipedia: Linear Feedback Shift Register (2014)</li>
					<li>Dubrova, E.: A List of Maximum Period NLFSRs. IACR Cryptology ePrint Archive 2012 (2012) 166</li>
					<li>Ritter, T.: Randomness Tests: A Literature Survey (2007)</li>
					<li>L'Ecuyer, P, S.R.: TestU01 - A Software Library in ANSI C for Empirical Testing of Random Number Generators (2002)</li>
					<li>Marsaglia, G.: The Marsaglia Random Number CDROM including the Diehard Battery of Tests of Randomness (2005)</li>
					<li>Soto, J.: Statistical Testing of Random Number Generators. Proceedings of the 22nd National Information Systems Security Conference NIST, 1999 (1999)</li>
					<li>Berlekamp, E.R.: Nonbinary BCH decoding. University of North Carolina. Department of Statistics (1967)</li>
					<li>Massey, J.L.: Shift-register synthesis and BCH decoding. Information Theory. IEEE Transactions 15(1) (1969) 122-127</li>
					<li>Feng, G.-L., T.K.: A generalization of the Berlekamp-Massey algorithm for multisequence shift-register. Information Theory, IEEE Transactions 37(5) (2012) 1274-1287</li>
					<li>Rodrigez, S.: Implementation of a decoding algorithm for codes from algebraic curves in the programming language Sage. diploma thesis, Faculty of San Diego State University (2013)</li>
				</ol>
			</section>
				
			<section>
				<h2>Thanks for you attention!</h1>
				<h4>Questions?</h4>
				<small><a href="https://twitter.com/b_aldream">@b_aldream</a> | <a href="https://github.com/Aldream">git:Aldream</a> | <a href="http://aldream.net">aldream.net</a></small>
			</section>
			
			<section>
				<section>
					<h1>Annexe</h1>
				</section>
				
				<section>
					<h3>Berlekamp-Massey Algorithm <small>Alternate explanation</small></h3>
					<small>$S$ sequence, $F(x)$ polynomial, $ \beta_i^j(S_1, S_2) $ discrepancy</small>
					<ul>
						<li>Make a first guess for $F(x)$ (ex: $F(x) = 1$)</li>
						<li>At each iteration $l$:<ul>
							<li>Generate $S_l'$ of $l$ elements, from $F(x)$</li>
							<li>Compare $S$ and $S_l'$: $ \beta_0^l(S, S_l') $</li>
							<li>We know $S_l'$ correct up to the $(l-1)^{th}$ symbol</li>
							<li> If $l^{th}$ symbol not correct, ie $ \beta_0^l(S, S_l') = (0,0,0,...,1) $:<ul>
								<li>Last iteration $m$ when this happened, we had $ \beta_0^m(S, S_m') = (0,0,0,...,1) $</li>
								<li>So $ \beta_0^l(S, S_l') + \beta_{l-m}^l(S, S_m') = (0,0,0,...,0) \to$ correction to apply</li>
								<li>$F(x) \gets F(x) + x^mF_l(x)$ </li>
							</ul></li>
					</ul>

					<aside class="notes">
<ul>
<li>At each iteration, it evaluates the discrepancy (difference between things that should be the same)</li>
<li>If beta = 0, F(x) and L are still currently correct -&gt; go next iteration</li>
<li>If beta != 0, F(x) should be concordantly adjusted, by shifting + scaling the syndromes added since the last update of L </li>
<li>In order to keep track of the number of errors and current degree of the
polynomial, L should be updated, otherwise the discrepancies will reach 0 before l grows bigger than 2L.</li>
</ul>					
					</aside>
				</section>

			</div>

		</div>

		<script src="../js/reveal.js-2.6.1/head.min.js"></script>
		<script src="../js/reveal.js-2.6.1/reveal.min.js"></script>
		
		<script type="application/javascript;version=1.7" src="random-number-generator/implementation/prng.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				width: 1600,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',
				
				
				math: {
					mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
					config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
				},

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../js/reveal.js-2.6.1/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../js/reveal.js-2.6.1/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../js/reveal.js-2.6.1/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../js/reveal.js-2.6.1/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../js/reveal.js-2.6.1/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../js/reveal.js-2.6.1/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					 { src: '../js/reveal.js-2.6.1/plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
